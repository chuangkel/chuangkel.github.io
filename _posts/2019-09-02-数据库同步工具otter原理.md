---
layout:     post
title:	java反射和代理
subtitle: 	java反射和代理
date:       2019-09-01
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

#  数据库同步工具otter原理







* 基于行的复制



* 基于语句的复制



* 异步复制

![img](/../img/数据库异步复制.png)



* 半同步复制

![img](/../img/数据半同步复制.png)



复制过程中的线程

* 主库开启dump thread复制响应从库IO thread请求

* 从库开启IO thread，负责连接主库，请求binlog,将binlog写入relay-log(中继日志)
* 从库开启 Sql thread，负责执行relay-log事件



#### bin log和redo log及undo log的区别？

> bin log 先于redo log产生，可以在my.cnf配置文件中配置相关参数

* bin log
  * 在服务层产生，针对大多数存储引擎
  * 全量拷贝，事务所有的操作。T事务增加一行row，然后删除row，会记录下操作过程。
* sync_binlog参数：控制bin log 同步到磁盘的频率
    * sync_binlog默认值0，不主动同步
    * sync_binlog值为1，每写一次bin log 同步一次磁盘，最安全
  
* redo log
  * 在存储引擎层，是innodb产生的
  * 事务终态拷贝，具有幂等性，T事务增加一行row，然后删除row，相当于记录不会修改。
  * redo log包括内存缓冲日志（redo log buffer）、磁盘持久化日志（redo log file）两部分。内存缓冲日志持久化到磁盘通过参数innodb_flush_log_at_trx_commit 来控制
    * innodb_flush_log_at_trx_commit 为1，事务提交立刻提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据安全，耗时较长）
    * innodb_flush_log_at_trx_commit 为0，每秒钟提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短）
    * innodb_flush_log_at_trx_commit 为2，事务提交立刻提交redo log buffer 到 os buffer，并且每秒调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短，可以防止mysqld 进程崩溃造成的数据丢失）
* fsync()系统调用，将内核缓存提交到磁盘

![img](/../img/fsync用户空间到内核空间)

* undo log

  > undo log提供回滚和多个行版本控制(MVCC)，事务失败回滚时，会借助undo log进行回滚。
  >
  > * 回滚：undo log 是逻辑日志（redo log 是物理日志），undo log 会记录相反的操作（delete 一条记录会产生一条insert记录的日志，update会产生一条相反的update日志）。
  >
  > * 多个行版本控制(MVCC)：某一行被锁定而需要读取时，从undo log日志中解析出上一个版本记录的数据，实现非锁定一致性读取。



### InnoDB页结构

> InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB。一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。InnoDB有多种页，索引页，Undo页，Inode页，系统页，BloB页等。

![img](/../img/innodb页结构图.jpg)

#### 为什么innodb表最大支持64TB?

innodb的页号是一个32bit int类型数值，一页大小默认为16KB，那么最多有2^32 * 16kb =  64TB




