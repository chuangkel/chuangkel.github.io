---
layout:     post
title:	jvm基本原理
subtitle: 	jvm基本原理
date:       2019-08-19
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# jvm基本原理

## jvm内存结构

* 线程私有：虚拟机栈（本地虚拟机栈），程序计数器
* 线程公共：堆，方法区

java堆划分为两个区域: 新生代(young)、老年代(old)

新生代又分为三个区域：eden,from survivor,to survivor

#### 虚拟机栈

> 会抛出两种异常：
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
>
> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。



局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这
个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变
量表的大小。

#### java堆

> 会抛出OutOfMemoryError异常。

#### 为什么要指定堆的初始最大值和最小值？

堆的大小用-Xms（初始堆大小）、-Xmx（最大堆大小）指定

新生代 eden:from:to = 8:1:1可以通过-XX:SurvivorRatio来指定

两种gc:minor gc和full gc (major gc)

eden+from作为新生代使用的区域，进行gc之后，判断存活对象大小是否小于to的大小，小于拷贝到to区，然后清除掉eden和from区域，并将还存活的对象的年龄+1，当达到15（默认）之后进入老年代  -XX:MaxTenuringThreshold可以设定进入老年代的年龄，对于大的对象也可以直接进入老年代。

## jvm内存模型

主线程+工作线程

| 回收算法 | 思想 | 所用的地方 |
| -------- | ---- | ---------- |
| 标记复制 |      | 新生代     |
| 标记清除 |      | 老年代     |
| 标记整理 |      | 老年代     |
|          |      |            |

