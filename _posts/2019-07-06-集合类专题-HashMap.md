---
layout:     post
title:	集合类专题
subtitle: 	HashMap
date:       2019-07-06
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# HashMap

hash值计算过程，把hashCode的高位和低位做异或运行，作为hash值的低位。因为(hash & n - 1) 作为数组的索引下标，大多数情况都是使用低位的，把高位也加入到hash值低位的计算，保证了低位hash值的散列均匀程度。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

红黑树的五个特性

1. 树节点只有红节点和黑节点构成。
2. 根节点是黑节点。
3. 叶子节点是黑节点。
4. 黑高相同，即从根节点到叶子结点的黑色节点数量相同。
5. 不存在两个直接相连的红色节点。

通过上面的五个特性保证了红黑树的自适应平衡，节点数指定情况下不会出现深度过深，对检索查找节点的时间复杂度的稳定性很好，时间复杂度为logn

```java
//红黑树左旋
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    TreeNode<K,V> r, pp, rl;
    if (p != null && (r = p.right) != null) {
        if ((rl = p.right = r.left) != null)
            rl.parent = p;
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        r.left = p;
        p.parent = r;
    }
    return root;
}
```

扩容

jdk1.7的扩容，链表的部分会造成节点顺序反转，因为扩容过程中采用的是前插法，数组下标位置的节点为链表头结点，扩容必须是从头结点开始转移节点，插入到新table里面是采用前插法导致了链表节点的顺序反转。多线程情况下会导致循环链表死循环CPU100%的情况。

jkd1.8的扩容，放弃了扩容过程中的前插法，对每个节点进行计算（hash & bit) 只能为0或1，bit为原数组的长度，这样为了将节点先分为lo和hi两个链表中，再对两个链表判断，将数量大于8转换成红黑树，将数量小于6转换成链表。同时维护了节点之间的顺序。扩容把原始容量扩大到了原来的两倍，扩容过程中对原节点的转移也分成了高低两个部分。