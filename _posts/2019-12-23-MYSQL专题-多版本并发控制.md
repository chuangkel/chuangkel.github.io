---
layout:     post
title:	MYSQL专题
subtitle: 	多版本并发控制
date:       2019-12-23
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

# 多版本并发控制

**MVCC最大的优点是读不加锁，读写不冲突。**



共享锁（共享读 也可以排他读）和排它锁  共享锁之间可以兼容 共享锁和排它锁不可以兼容 。   

多版本控制MVCC，读不用加锁，写加锁，读写不冲突（隐藏的ID，修改事务ID，删除事务ID，回滚点PT，读只能读去修改事务ID小于等于当前事务ID的版本并且删除事务版本为空或删除事务版本大于当前事务版本）

行锁设计的目的是为了提升的并发性能，而多版本控制（MVCC）是为了得到更高的并发性能。



Select时只能查询到小于等于当前事务版本号的行，并且当删除时间为空或者大于当前版本号的行。

Insert为新插入的行保存当前系统版本号为最新的行的版本号。

Update为插入一行新纪录，保存当前系统版本号为新记录行版本号，同时保存当前系统版本号为原来行的删除记录的版本号。

Delete为删除的每一个行保存当前系统版本号为删除的每一行的行版本号。



隐藏的三列： 1. 隐藏的ID（ID） 2. 记录执行事务的事务ID（DB_TRX_ID） 3.指向回滚点的回滚指针（DB_ROLL_PT）

例子1：A事务进行读，同时B事务对A读的同一行进行了修改，但是A事务只能看到小于等于自身事务ID的版本，看不到大于A事务ID的版本（即B事务修改数据增加了版本行，事务ID增加）。B事务提交了，A事务再次读，也读取不到B事务修改的数据。

例子2：A事务进行读，同时B事务进行删除，删除也是修改的一种，会增加版本，修改删除事务ID为当前事务，这个时候B提交了， A事务可以看到数据被删除了吗？

A只能看到小于等于A当前事务的事务ID的版本的数据，等于的情况（A事务自身修改的数据） 并且 删除事务ID 大于当前事务ID的版本（这个是不是幻读了？）。



多版本控制实验：

| 时间线 | 事务A                                                        | 结果            | 事务B                                                        | 结果               |
| ------ | ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ | ------------------ |
|        | SELECT * from person where id = 1;                           | 1	tom@qq.com |                                                              |                    |
|        | set autocommit=off;<br/>START TRANSACTION;<br/>UPDATE person set email = "Jhon@foxmail.com" where id = 1; | 受影响的行: 1   |                                                              |                    |
|        | SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID = CONNECTION_ID(); | 87337           |                                                              |                    |
|        |                                                              |                 | set autocommit=off;<br/>start TRANSACTION;<br/>select * from person where id = 1; | 1	tom@qq.com    |
|        |                                                              |                 | SELECT TRX_ID FROM INFORMATION_SCHEMA.INNODB_TRX  WHERE TRX_MYSQL_THREAD_ID = CONNECTION_ID(); | TRX_ID 87338       |
|        | commit;                                                      | [SQL]commit;    |                                                              |                    |
|        |                                                              |                 | select * from person where id = 1;<br/>COMMIT;               | 1	tom@qq.com    |
|        |                                                              |                 | set autocommit=off;<br/>start TRANSACTION;<br/>select * from person where id = 1;<br/>COMMIT; | 1 Jhon@foxmail.com |

通过上面的实验可以看出,A事务先启动，进行了id=1行数据的修改，事务B这个时候启动，B的事务ID在A事务ID增加了1为87338，实验显示B事务确实看不到A事务的修改，即使A事务提交了数据之后B事务仍然看不到A的修改，这是为什么呢？ 

多版本控制下，复制的版本之后，未提交版本之前，该版本是锁定的吗？ 修改的事务ID或者删除的事务ID是什么时候写入的？ 为什么上面的B事务不能看到A事务的修改的数据。

猜测： 如果开启了多版本控制，复制的版本（未提交）应该是锁定的，即使像B这样的读事务也看不到。

至于A事务对复制的版本什么时候写入 修改事务ID和删除事务ID 这并不重要，确定的是一定会在事务提交之前写入事务ID到版本。

那么开启了多版本控制吗？

SELECT  VERSION(); -- 5.6.38

非锁定的列、版本

 
