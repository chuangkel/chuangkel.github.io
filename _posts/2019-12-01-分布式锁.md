---
layout:     post
title:	分布式锁
subtitle: 	
date:       2019-12-01
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - spring
---

# 分布式锁


## 分布式锁

> 单机系统中，并发场景读取公共资源时，使用同步或者加锁就可以实现。但是应用分布式了之后系统由以前的单进程多线程的程序变为了多进程多线程，这时使用以上的解决方案明显就不够了。
>
> 需满足锁的一般特征：
>
> - 高性能(加、解锁时高性能）
> - 可以使用阻塞锁与非阻塞锁
> - 不能出现死锁
> - 可用性(不能出现节点 down 掉后加锁失败)
>
> 任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。



###zookeeper方式实现

> 基于 ZK 的临时有序节点
>
> 客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

- 锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。
- 非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
- 不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。
- 单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。

可以直接使用zookeeper第三方库`Curator`客户端，这个客户端中封装了一个可重入的锁服务。Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。

* 优点

有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题

* 缺点

性能上不如使用缓存实现分布式锁



### 使用缓存(redis)方式实现

> 基于 Redis 的 NX、EX参数（NX键存在不能set，不存在可以set；EX超时时间，自动删除key)
>
> ```redis
> redis 127.0.0.1:6379> SET KEY VALUE [EX seconds] [PX milliseconds] [NX|XX]
> ```
>
> - EX seconds - 设置指定的到期时间，单位为秒
> - PX milliseconds - 设置指定到期时间，单位为毫秒
> - NX - 只有设置键，如果它不存在
> - XX - 只有设置键，如果它已经存在
>
> ```redis
> redis 127.0.0.1:6379> SET yiibai redis EX 60 NX //如果该键不存在，将设置键yiibai，60秒到期
> OK //返回值：如果值被设置，回复OK；如果值不设置返回为null
> ```

缺点：

- 如在 key 超时之后业务并没有执行完毕但却自动释放锁了，这样就会导致并发问题(租约锁)
- 就算 Redis 是集群部署的，如果每个节点都只是 master 没有 slave，那么 master 宕机时该节点上的所有 key 在那一时刻都相当于是释放锁了，这样也会出现并发问题。就算是有 slave 节点，但如果在数据同步到 salve 之前 master 宕机也是会出现上面的问题

### 数据库方式实现

> 有两种方式（都是基于唯一索引）：基于数据库表、基于数据库排他锁

#### 基于数据库表增删

> 通过表中的记录的存在情况确定当前是否有锁存在

#### 基于数据库排他锁

> 通过数据库的排他锁来实现分布式锁。行级锁不一定靠谱，method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。

* 缺点
  * 当表数据量不大时，mysql会优化执行sql，不一定使用行锁而采用表锁，增加数据库连接从而撑爆数据库连接池。
  * 数据库时单点的，可以采用双向同步，遇故障切换。

