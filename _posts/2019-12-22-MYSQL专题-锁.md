---
layout:     post
title:	MYSQL专题
subtitle: 	锁
date:       2019-12-22
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

# 锁

**引言**

1. 行锁是加在索引上的吗？
3. 行锁是怎么实现的？
3. 有什么可以查看事务加锁的情况？
4. record lock 、gap lock 、next-key lock 算法的用途和区别？
5. 什么情况下会锁一张表？锁全表的方式？如何避免锁全表？

**分析**

### 1. 行锁是加在索引上的吗？ 

   查看一下有主键和没有主键的执行计划的差别：

```mysql
-- 没有主键的表结构
CREATE TABLE `t1` (
  `id` int(11) NOT NULL,
  `name` varchar(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
-- 结果扫描了6行，全表扫描了。
```

![1570612398476](/..\img\1570612398476.png)

```mysql
-- 有主键的表结构
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `name` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
-- 可以看到只扫描了一行。查询对行加排他锁。
```

![1570612085370](/..\img\1570612085370.png)

**结论：**

扫描的行数和有没有索引是有关系的，若查询条件能走索引，这会通过索引查找。反之全表扫描。这并不能说明行锁是加在索引上的，该怎么证明呢？

设计实验证明： 分两种情况，有索引和没索引实验。

**有索引：**

```mysql
-- section A
BEGIN;
SELECT * from t WHERE id = 3 for UPDATE;
-- section B
BEGIN;
SELECT * from t WHERE id = 5 for UPDATE;
```

Section A 结果：

![1570613014245](/..\img\1570613014245.png)

Section B结果：

![1570612982100](/..\img\1570612982100.png)

**没有索引：**

```mysql
-- section A
BEGIN;
SELECT * from t1 WHERE id = 3 for UPDATE;
-- section B
BEGIN;
SELECT * from t1 WHERE id = 5 for UPDATE;
```

Section A 结果：

![1570613014245](/../img/1570613014245.png)

Section B 结果：

![1570613166117](/../img/1570613166117.png)

**结果分析：加索引情况for update对行加了排他锁，但是各个行锁直接兼容而不会影响。没有加索引情况下for update对表加了表排他锁，所以第二个事务执行的时候被第一个事务阻塞住了，需等第一个事务释放表排他锁之后才能继续执行。这足以说明添加索引的重要性，可以降低加锁的粒度，减少资源占用，提高并发量。 提个问题： 该实验中可以使用共享锁来实验吗，即改成lock in share mode,答案是否定的，因为两个共享锁是兼容的**

注意： 实验的条件是查询条件需走索引和不走索引来控制的。

***由此得出：行锁是加在索引上的。因为没有索引情况下没用使用行锁而使用了表锁。***

### 2. 行锁是怎么实现的？

行锁是基于索引来实现的，或者说是加在索引上的，这一点和oracle是不同的。如果表没有建立索引，primary key、unique key或者key普通索引，则不能使用行锁而使用表锁。

在对行加共享锁之前先对表加意向共享锁。

在对行加排它锁之前先对表加意向排它锁。

意向锁是为了防止行锁和表锁的加锁过程中全表扫描，加上意向锁提供后来的事务判断。

若事务B请求行级排它锁（X）即请求意向排它锁（IX），发现表被事务A加了意向排它锁（IX），由于意向排它锁（IX）可以兼容，事务B加上意向排它锁（IX）之后再对具体的行加行级排它锁（X）。

若事务B请求表级排它锁（X），发现表被事务A加了意向排它锁（IX），由于意向排它锁（IX）和表级锁（X）不可以兼容， 事务B必须等待事务A的意向排它锁（IX）的释放。

若事务B请求行级共享锁（S）即请求意向共享锁（IS），发现表被事务A加了意向排它锁（IX），由于意向共享锁（IS）和意向排它锁（IX）可以兼容，事务B可以获取意向共享锁（IS)，然后再请求行级共享锁（S)，设计实验验证一下。

若事务B请求表级共享锁（S），发现表被事务A加了意向排它锁（IX），由于表级共享锁（S）和意向排它锁（IX）不可以兼容， 事务B必须等待事务A的意向排它锁（IX）的释放，才能获取表级共享锁。

| 请求事务/是否兼容/当前事务 | S      | X      | IS     | IX     |
| -------------------------- | ------ | ------ | ------ | ------ |
| S                          | 兼容   | 不兼容 | 兼容   | 不兼容 |
| X                          | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| IS                         | 兼容   | 不兼容 | 兼容   | 兼容   |
| IX                         | 不兼容 | 不兼容 | 兼容   | 兼容   |

注意： S和X锁有表级和行级。

### 3. 有什么可以查看事务加锁的情况？

在没有索引情况下两个事务阻塞了，如下msyql语句：

```mysql
-- section A
BEGIN;
SELECT * from t1 WHERE id = 3 for UPDATE;
-- section B
BEGIN;
SELECT * from t1 WHERE id = 5 for UPDATE;
```

没有索引会锁全表，为啥lock_page、lock_rec和lock_date不为null呢？

![1570622046837](/..\img\1570622046837.png)

![1570622288286](/..\img\1570622288286.png)



### 4. record lock 、gap lock 、next-key lock 算法的用途和区别？



### 5. 什么情况下会锁一张表？锁全表的方式？如何避免锁全表？

1. where条件不走索引会锁全表。
2. 没有where条件会锁全表，实验一下，好像是不对的。
3. lock table t read、lock table t write 来锁全表。


## 正文

### 锁粒度

> 锁策略：在锁的开销和数据安全性之间寻求平衡。常见两种锁策略，表锁(table lock)和行锁(row lock)。

### 表锁(table lock)

> 表锁(table lock)是mysql中最基本的锁策略，也是开销最小的锁策略。一个用户在对表进行写操作（增加，删除，修改）前，需要先获取写锁，写锁会阻塞其他写锁和读锁。写锁的优先级比读锁的优先级高，写锁可以插入到锁队列中读锁的前面。

```mysql
lock table t read; -- 加表级读锁
lock table t write; -- 加表级写锁
UNLOCK tables -- 释放锁
```

### 行锁(row lock)

> 行锁(row lock)只在存储引擎层实现。服务器层完全不了解行锁的实现。InnoDB和XtraDB实现了行级锁。

### 页面锁

> 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## 共享锁、排他锁与意向锁

共享锁与独占锁均用于事务当中，随事务的结束而解除。

**共享锁（share lock，S锁）**

又称读锁，读取操作创建的锁。

一旦上锁，任何事务（包括当前事务）无法对其修改，其他事务可以并发读取数据，也可在对此数据再加共享锁

语法：SELECT ... LOCK IN SHARE MODE

**排他锁（exclusive lock，X锁）**

又称写锁，如果事务对数据A加上排他锁后，则其他事务不可并发读取数据，也不能再对A加任何类型的锁。获准排他锁的事务既能读数据，又能修改数据。

语法：SELECT ... FOR UPDATE

**意向锁（IS锁，IX锁）**

**InnoDB所用的**表级锁，其设计目的主要是为了在一个事务中揭示下一步将要被请求的锁的类型。

InnoDB中的两个表锁：

意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁

意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

**意向锁是InnoDB自动加的，不需要用户干预。**

#### 意向锁的分类：

意向共享锁，事务想要给数据库某些行加共享锁，需要先获取意向共享锁
意向互斥锁，事务想要给数据库某些行加互斥锁，需要先获取意向互斥锁
意向锁是表锁，提高加表锁和行锁之间冲突时的判断效率。

**问题：为什么需要意向锁？**
主要为了实现多粒度锁。

LOCK TABLE table_name READ；用共享锁锁住整个表
LOCK TABLE table_name WRITE；用互斥锁锁住整个表
**分析：**假设没有意向锁，事务A使用行锁锁住其中一行，事务B申请表的互斥锁，然后修改整个表，行锁和表锁就会发生冲突，要解决冲突，事务B需要等待事务A锁住的行锁释放，但是事务B并不知道事务A锁住的是哪一行，所以事务B会遍历数据库每一行判断是否有行锁，这是一个非常耗时的过程。

为了解决上述问题引入意向锁，事务A在加行锁前，先需要给表加上对应的意向锁，这样如果事务B来获取表锁，需要先判断表上是否有意向锁，如果有意向锁，则阻塞，等待事务A的锁释放。**提高加表锁和行锁之间冲突时的判断效率。**

意向锁和表锁之间兼容关系：

|           | 意向共享锁(IS) | 意向互斥锁(IX) |
| --------- | -------------- | -------------- |
| 共享锁(S) | 兼容           | 互斥           |
| 互斥锁(X) | 互斥           | 互斥           |

## 元数据锁

元数据锁属于表锁范畴，元数据即数据字典信息

MDL 不需要显式使用，在访问一个表的时候会被自动加上
MDL的作用是维护数据的一致性
问题： 为什么需要元数据锁
线程A查询数据库，线程B对表结构进行变更，比如说删除某一列，修改列名，那么查询结果和数据库表结构对应不上，这就冲突了

MDL锁不需要显示使用，在访问表结构的时候被自动加上
对表做增删改查操作，加MDL读锁，对表结构变更的时候加MDL写锁
兼容性和正常行锁读写锁保持相同，读读兼容，读写，写写不兼容
MDL锁可能带来的问题：

事务A查询表记录，事务B给表加字段，事务C查询表记录

事务A会给表加MDL读锁，事务B会加MDL写锁，事务C给表加读锁

读写锁不兼容，事务B必须等待事务A提交结束才能继续执行，事务C虽然是读锁，读锁之间相互兼容，但是由于事务B的存在，也会阻塞，如果这时查询请求很频繁，会造成大量请求失败。

## 乐观锁和悲观锁

1. 什么是乐观锁和悲观锁？

## 死锁

> 死锁是两个或者多个事务在同一资源上的相互占用，并请求锁定对方占用的资源。

#### 参数设置：

innodb_rollback_on_timeout 这个参数关闭或不存在的话遇到超时只回滚事务最后一个Query，打开的话事务遇到超时就回滚整个事务。innodb_rollback_on_timeout  = OFF 不会回滚超时引发的异常事务 死锁的除外；innodb_rollback_on_timeout = ON 则会。 

```shell
[mysqld] #只能在[mysqld]下面添加 否则不生效
innodb_rollback_on_timeout=1
# 配置文件中设置，重启生效
# windwos设置之后重启msyql
# net stop mysql
# net start mysql
```

```mysql
show VARIABLES like 'innodb_rollback_on_timeout' -- 查看设置
```

#### 死锁实践

事务一开启，执行前半截；然后事务二执行就可以发现资源等待情况，如果事务一继续执行后半截的话，就会发现死锁。mysql会自动检测死锁，当发生死锁时，会回滚最少持有行级锁的事务。

```mysql
-- 事务一
set autocommit = 0;
START TRANSACTION;
UPDATE stockprice set `close` = 1 where stock_id = 5 and date = '2019-10-04';
UPDATE stockprice set `close` = 1 where stock_id = 3 and date = '2019-10-02';
UPDATE stockprice set `close` = 1 where stock_id = 4 and date = '2019-10-03';
COMMIT;
-- 事务二
set autocommit = 0;
START TRANSACTION;
UPDATE stockprice set `close` = 2 where stock_id = 4 and date = '2019-10-03';
UPDATE stockprice set `close` = 2 where stock_id = 3 and date = '2019-10-02';
COMMIT;
```

等待超时之后的结果：

```
[SQL]
UPDATE stockprice set `close` = 2 where stock_id = 4 and date = '2019-10-03';
[Err] 1205 - Lock wait timeout exceeded; try restarting transaction
```

死锁时回滚最小持有行的事务
