---
layout:     post
title:	MYSQL专题
subtitle: 	锁
date:       2019-12-22
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

# 锁

锁粒度

> 锁策略：在锁的开销和数据安全性之间寻求平衡。常见两种锁策略，表锁(table lock)和行锁(row lock)。

### 表锁(table lock)

> 表锁(table lock)是mysql中最基本的锁策略，也是开销最小的锁策略。一个用户在对表进行写操作（增加，删除，修改）前，需要先获取写锁，写锁会阻塞其他写锁和读锁。写锁的优先级比读锁的优先级高，写锁可以插入到锁队列中读锁的前面。alter table 会使用表锁。

### 行锁(row lock)

> 行锁(row lock)只在存储引擎层实现。服务器层完全不了解行锁的实现。InnoDB和XtraDB实现了行级锁。



### 乐观锁



### 悲观锁



### 共享锁（读锁）

读锁是共享的，多个客户可以同一时间读取同一个资源而相互不干扰。

### 排它锁（写锁）

写锁是相互排斥的



### 死锁

> 死锁是两个或者多个事务在同一资源上的相互占用，并请求锁定对方占用的资源。

#### 参数设置：

innodb_rollback_on_timeout 这个参数关闭或不存在的话遇到超时只回滚事务最后一个Query，打开的话事务遇到超时就回滚整个事务。

```shell
[mysqld] #只能在[mysqld]下面添加 否则不生效
innodb_rollback_on_timeout=1
# 配置文件中设置，重启生效
# windwos设置之后重启msyql
# net stop mysql
# net start mysql
```

```mysql
show VARIABLES like 'innodb_rollback_on_timeout' -- 查看设置
```

#### 死锁实践

事务一开启，执行前半截；然后事务二执行就可以发现资源等待情况，如果事务一继续执行后半截的话，就会发现死锁。mysql会自动检测死锁，当发生死锁时，会回滚最少持有行级锁的事务。

```mysql
-- 事务一
START TRANSACTION;
UPDATE stockprice set `close` = 2 where stock_id = 4 and date = '2019-10-03';
UPDATE stockprice set `close` = 2 where stock_id = 3 and date = '2019-10-02';
COMMIT;
-- 事务二
START TRANSACTION;
UPDATE stockprice set `close` = 1 where stock_id = 3 and date = '2019-10-02';
UPDATE stockprice set `close` = 1 where stock_id = 4 and date = '2019-10-03';
COMMIT;
```

等待超时之后的结果：

```
[SQL]
UPDATE stockprice set `close` = 2 where stock_id = 4 and date = '2019-10-03';
[Err] 1205 - Lock wait timeout exceeded; try restarting transaction
```

死锁时回滚最小持有行的事务



#### 怎样锁一

#### 张表？

在查询的时候如果没有走索引，会锁整张表？





### 扩展

> for update : 走索引使用行锁，不走索引使用表锁。

```mysql
set autocommit = 0; -- 0 关闭自动提交；1 开启自动提交
select * from d_topnholder where id = 1 for UPDATE; -- 行锁
COMMIT;-- 释放锁
```



