---
layout:     post
title:	线程那些事儿
subtitle: 	线程那些事儿
date:       2019-08-07
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 线程 & 线程池
---

# 线程那些事儿

### interrupt()的理解

```java
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
	
   /**如果抛出异常，会清除中断状态 interrupted status
 	 * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;
```

> interrupt() 只改变中断状态，不会终止线程执行

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            while (true){} //endless loop
        });
        thread.start();
        thread.interrupt(); //只改变中断状态，并没有结束线程
}
//使用姿势
public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            while (!Thread.currentThread().isInterrupted()){
                System.out.println("sub thread is over");
            }
        });
        thread.start();
        Thread.sleep(100);
        thread.interrupt();
}
```

> thread.interrupt()中断时，若thread处于挂起，则会抛出中断异常

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            try {
                Thread.sleep(100); //抛出异常之前将中断状态置为false
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().isInterrupted());
            }
        });
        thread.start();
        thread.interrupt(); //将中断状态置为true
}
```

### interrupted()  **VS**  isInterrupted()

```java
public static boolean interrupted() {
       return currentThread().isInterrupted(true);//会清除中断状态
}
public boolean isInterrupted() {
       return isInterrupted(false);//不会清除中断状态
}
private native boolean isInterrupted(boolean ClearInterrupted);
```

### 总结：哪些情况下会清除中断状态？

* 用interrupted()来判断当前中断状态时，返回当前中断状态，并清除中断状态为false 。本质上是 isInterrupted(true) 
* 调用interrupt()方法时，当前线程处于挂起状态，会清除中断状态并抛出异常，如下情形会使线程挂起：
  * Object#wait() 、Object#wait(long) 、Object#wait(long, int)
  * Object#join() 、Object#join(long) 、Object#join(long, int)
  * Object#sleep(long) 、Object#sleep(long, int)
  * If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel} then the channel will be closed
  * If this thread is blocked in a {@link java.nio.channels.Selector} then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value