---
layout:     post
title:	JVM专题
subtitle: 	第三部分：虚拟机执行子系统
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# 第三部分：虚拟机执行子系统

## 类文件结构

类文件结构中组成部分的排列顺序是**魔术和Class文件的版本，常量池，访问标志，类索引父类索引与接口索引集合，字段表集合，方法表集合，属性表集合**

* 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）
* 实现语言无关性的基础仍然是**虚拟机和字节码存储格式**。Java虚拟机不和包括Java在内的任何语言绑定，**java虚拟机只与“Class文件”这种特定的二进制文件格式所关联**，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，**虚拟机并不关心Class的来源是何种语言**。
* Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。
*  **任何一个Class文件都对应着唯一一个类或接口的定义信息**，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。
* Class文件是一组以**8位字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
* 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有**两种数据类型：无符号数和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。
* **无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
* **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

### 魔数与Class文件的版本



### 常量池

javac JavapTest.java

javap -verbose JavaTest.class

```java
public class JavapTest {
    int a = 1;
    int aa = 2;
}
```

```
  MD5 checksum 58b88c85c197d544ff05d0dd49d96580
  Compiled from "JavapTest.java"
public class com.github.chuangkel.java_learn.base.bases.JavapTest
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #4                          // com/github/chuangkel/java_learn/base/bases/JavapTest
  super_class: #5                         // java/lang/Object
  interfaces: 0, fields: 2, methods: 1, attributes: 1
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#16         // com/github/chuangkel/java_learn/base/bases/JavapTest.a:I
   #3 = Fieldref           #4.#17         // com/github/chuangkel/java_learn/base/bases/JavapTest.aa:I
   #4 = Class              #18            // com/github/chuangkel/java_learn/base/bases/JavapTest
   #5 = Class              #19            // java/lang/Object
   #6 = Utf8               a
   #7 = Utf8               I
   #8 = Utf8               aa
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               SourceFile
  #14 = Utf8               JavapTest.java
  #15 = NameAndType        #9:#10         // "<init>":()V
  #16 = NameAndType        #6:#7          // a:I
  #17 = NameAndType        #8:#7          // aa:I
  #18 = Utf8               com/github/chuangkel/java_learn/base/bases/JavapTest
  #19 = Utf8               java/lang/Object
{
  int a;
    descriptor: I
    flags: (0x0000)

  int aa;
    descriptor: I
    flags: (0x0000)

  public com.github.chuangkel.java_learn.base.bases.JavapTest();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: aload_0
        10: iconst_2
        11: putfield      #3                  // Field aa:I
        14: return
      LineNumberTable:
        line 9: 0
        line 10: 4
        line 11: 9
}
SourceFile: "JavapTest.java"
```

常量池可以分成两部分，字面量和符号引用。每个类型都是一个表，由u结构或u和表结构构成。每种常量池的结构的命名都是以_info结尾的，表示是一个表结构。

字面量：文本字符串和final常量。

符号引用：类和接口符号引用、方法符号引用、字段符号引用。

常量池的分类：CONSTANT_Utf8_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Double_info、CONSTANT_String_info（字节码中的，在运行时存放在堆中）、CONSTANT_Class_info、CONSTANT_Methodref_info、CONSTANT_Fieldref_info、CONSTANT_Interface_Method_info、CONSTANT_NameAndType_info(字段和字段类型对应关系常量池)、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_Invoke_Dynamic_info。

CONSTANT_Utf8_info是作为其他常量池表结构中的一部分(基础部分)，即其他的常量池比如CONSTANT_Class_info中指向了CONSTANT_Utf8_info中的地址。

![1569652816366](/../img/1569652816366.png)

### 访问标识

常量池之后紧接着是两个字节的访问标识(assecc flags)，用于描述改字节码文件是类还是接口，和访问的权限（public或者是default包默认访问级别）是否是final,是否是abstract等。

![1569653164983](/..\img\1569653164983.png)

### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2的数据，而接口索引集合是一组u2的数据。类索引为例，它指向的是常量池的CONSTANT_Class_info表里的数据行a,该数据a再指向常量池的CONSTANT_Utf8_info里面的数据行。父类索引用于确定这个类的全限定名，没有继承默认的父类为Object，Object的父类索引为空。

### 字段表集合

![1569657050063](/..\img\1569657050063.png)

字段类型

字段的修饰符 public、private、protected,默认包类型,；static;final;transient;voliate;

![1569653997069](/..\img\1569653997069.png)



### 方法表集合

方法表结构

![1569656980205](/..\img\1569656980205.png)

方法的修饰符 private,protected,public;synchronized;final;static;

![1569657010832](/..\img\1569657010832.png)

### 属性表集合

#### Code属性

Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。整个class文件分为元数据和代码，这个代码就是code索性，可见其重要性。

![1569682510429](/..\img\1569682510429.png)

1. **attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”**，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。

2. **max_stack代表了操作数栈（Operand Stacks）深度的最大值**。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（StackFrame）中的操作栈深度。

3. **max_locals代表了局部变量表所需的存储空间**。在这里，max_locals的单位是**Slot**,Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。**方法参数（包括实例方法中的隐藏参数“this”）**、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、**方法体中定义的局部变量都需要使用局部变量表来存放**。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。
4. **code_length和code用来存储Java源程序编译后生成的字节码指令**。code_length代表字节码长度，**code是用于存储字节码指令的一系列字节流**。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个**u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令**。

Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。

#### Execption属性



## 虚拟机类加载机制

> - 代码编译的结果是把机器码转换成了字节码（class文件），是存储格式的一小步，确实编程语言进步的一大步。
> - 类加载机制就是将字节码（class文件）加载进虚拟机。



* class文件描述的各种信息，最终都需要加载到虚拟机中才能运行和使用。
* 虚拟机的类加载机制：虚拟机把描述类的数据加载进内存，并对数据进行校验 ，转换解析并进行初始化，最终形成java虚拟机可以使用的java类型，这就是java虚拟机的类加载机制。

* 类的加载过程：加载、验证、准备、解析、初始化



### 类加载过程

类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。

#### 加载

这是类加载过程的第一个阶段，工程师对程序的控制性也最强，可以定义Class字节码文件的来源（网络、数据库或文件）。类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。自定义类加载器只需重写一个类加载器的loadClass()方法。

把Class二进制文件加载进方法区。

#### 验证

对方法区的Class二进制文件进行校验。

#### 准备

准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的**初始值**“通常情况”下是数据类型的**零值**，假设一个类变量的定义为

```java
public static int VALUE = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于**类构造器＜clinit＞()**方法之中，所以把value**赋值为123**的动作将在**初始化阶段**才会执行。

在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：

```java
public final static int VALUE = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在这个阶段，类装入器装入类所引用的其他所有类。可以用许多方式引用类：超类、接口、字段、方法签名、方法中使用的本地变量。

#### 初始化

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：**初始化阶段**是**执行类构造器＜clinit＞()**方法的过程。

＜clinit＞()方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块（static{}块）**中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```java
public class Test{
    static{
    i=0；//给变量赋值可以正常编译通过
    System.out.print（i）；//这句编译器会提示"非法向前引用"
    }
    static int i=1；
}
```

＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。由于父类的＜clinit＞()方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的静态语句块操作**。

```java
static class Parent{
    public static int A=1；
    static{
    A=2；
    }
}
static class Sub extends Parent{
    public static int B=A；
    }
    public static void main（String[]args）{
    System.out.println（Sub.B）；
}
```

＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。

虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

```java
static class DeadLoopClass{
    static{
        /*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/
        if（true）{
            System.out.println（Thread.currentThread（）+"init DeadLoopClass"）；
            while（true）{
            }
        }
    }
}
public static void main（String[]args）{
    Runnable script=new Runnable（）{
        public void run（）{
            System.out.println（Thread.currentThread（）+"start"）；
            DeadLoopClass dlc=new DeadLoopClass（）；
            System.out.println（Thread.currentThread（）+"run over"）；
        }
    }；
    Thread thread1=new Thread（script）；
    Thread thread2=new Thread（script）；
    thread1.start（）；
    thread2.start（）；
}
//Thread[Thread-0，5，main]start
//Thread[Thread-1，5，main]start
//Thread[Thread-0，5，main]init DeadLoopClass
```

到此，类已经完整装入，可以使用了。

类装入的方式有两种 —— *显式* 或 *隐式*，两者之间有些细微差异。

*显式* 类装入发生在使用以下方法调用装入的类的时候：

- `cl.loadClass()`（`cl` 是 `java.lang.ClassLoader` 的实例）
- `Class.forName()`（启动的类装入器是当前类定义的类装入器）

当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

*隐式* 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

类的装入通常组合了显式和隐式类装入。例如，类装入器可能先显式地装入一个类，然后再隐式地装入它引用的所有类。



* Java是一门静态语言，通常class在编译的时候就已经生成了，为什么有时候我们还想在运行时动态生成class呢？因为在有些时候得在运行时为一个类动态创建子类。比如编写一个ORM框架，如何得知一个简单的JavaBean是否被用户修改过呢？

其实`UserProxy`实现起来很简单，就是创建一个`User`的子类，覆写所有`setXxx()`方法，做个标记就可以了：


  但是这个`UserProxy`就必须在运行时动态创建出来了，因为编译时ORM框架根本不知道`User`类。

现在问题来了，动态生成字节码，难度有多大？

如果我们要自己直接输出二进制格式的字节码，在完成这个任务前，必须先认真阅读[JVM规范第4章](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)，详细了解class文件结构。估计读完规范后，两个月过去了。

所以，第一种方法，自己动手，从零开始创建字节码，理论上可行，实际上很难。

第二种方法，使用已有的一些能操作字节码的库，帮助我们创建class。

目前，能够操作字节码的开源库主要有[CGLib](https://github.com/cglib/cglib)和[Javassist](http://jboss-javassist.github.io/javassist/)两种，它们都提供了比较高级的API来操作字节码，最后输出为class文件。

比如CGLib，典型的用法如下：  

换一个思路，如果我们能创建`UserProxy.java`这个源文件，再调用Java编译器，直接把源码编译成class，再加载进虚拟机，任务完成！

毕竟，创建一个字符串格式的源码是很简单的事情，就是拼字符串嘛，高级点的做法可以用一个模版引擎。

如何编译？

Java的编译器是`javac`，但是，在很早很早的时候，Java的编译器就已经用纯Java重写了，自己能编译自己，行业黑话叫“自举”。从Java 1.6开始，编译器接口正式放到JDK的公开API中，于是，我们不需要创建新的进程来调用`javac`，而是直接使用编译器API来编译源码。

使用起来也很简单：

```
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
int compilationResult = compiler.run(null, null, null, '/path/to/Test.java');
```

 

这么写编译是没啥问题，问题是我们在内存中创建了Java代码后，必须先写到文件，再编译，最后还要手动读取class文件内容并用一个ClassLoader加载。

> 有木有更简单的方法？

有！

其实Java编译器根本不关心源码的内容是从哪来的，你给它一个`String`当作源码，它就可以输出`byte[]`作为class的内容。

所以，我们需要参考Java Compiler API的文档，让Compiler直接在内存中完成编译，输出的class内容就是`byte[]`。

代码改造如下：

> 除了写ORM用之外，还能干什么？

* 可以用它来做一个Java脚本引擎？



### 

# 指令重排







final 

volatile



```java
package com.github.chuangkel.java_learn.base.thread;
public class Test {
    private static int x = 0, y = 0;
    private static int a = 0, b =0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for(;;) {
            i++;
            x = 0; y = 0;
            a = 0; b = 0;
            Thread one = new Thread(new Runnable() {
                public void run() {
                    //由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.
                    shortWait(100000);
                    a = 1;
                    x = b;
                }
            });

            Thread other = new Thread(new Runnable() {
                public void run() {
                    b = 1;
                    y = a;
                }
            });
            one.start();other.start();
            one.join();other.join();
            String result = "第" + i + "次 (" + x + "," + y + "）";
            if(x == 0 && y == 0) {
                System.err.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }
    public static void shortWait(long interval){
        long start = System.nanoTime();
        long end;
        do{
            end = System.nanoTime();
        }while(start + interval >= end);
    }
}
```



# 字节码

泛型，编译器会自动生成桥接字节码

```java
public interface SupperClass<T> {
    void method(T t);
}
```

```java
public class SubClass implements SupperClass<String> {
    @Override
    public void method(String s) {
        System.out.println(s);
    }
}
```

```
Exception in thread "main" abc
java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String
	at com.github.chuangkel.java_learn.base.generic.SubClass.method(SubClass.java:9)
	at com.github.chuangkel.java_learn.base.generic.Main.main(Main.java:14)
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
```



# 第二部分：自动内存管理机制

## java内存区域与内存溢出异常

### 程序计数器

* 当前线程所执行的字节码的行号指示器
* 唯一一个没有OutOfMemoryError异常的区域

### 虚拟机栈

* 一个栈（虚拟机栈）供一个线程使用

* 一个方法调用对应一个栈帧，一个方法的调用过程就是一个栈帧入栈到出栈的过程。

* 一个虚拟机栈对应N个栈帧

* 栈帧 （存储了局部变量表，操作数栈、动态链接、方法出口等）

* 局部变量表：存储了八大基本类型（byte,boolean,short,char,int,float,long,double)、对象应用refrence类型、returnAddress类型（指向一条字节码的类型）
* double、long占用了两个局部变量空间，其余类型占用一个局部变量空间。局部变量的空间大小是编译时期就确定的，运行时不会改变。
* 两种异常：
  * 如果请求栈的深度（递归调用次数过多）超过规定的最大栈的深度，则抛出StackOverflowError异常。
  * 如果虚拟机栈可以动态扩展，当无法申请足够的内存时，则抛出OutOfMemoryError异常。

### 本地方法栈

* 和虚拟机栈的作用是类似的，也会抛出StackOverflowError异常和OutOfMemoryError异常。

### 方法区

* 方法区或称为永久代
* 存放常量（被final修饰），静态变量，类信息和即时编译后的代码等
* jdk1.7 已经把原本存放在永久代的字符串常量池移出。



#### 运行时常量池

* 定义：运行时常量池是方法区的一部分。class文件中除了版本，字段，方法，接口等信息外，还有一项信息是常量池，用于存放编译时期生成的字面量和符号引用。这部分内容是在类加载之后进入运行时常量池中存放的。

### java堆

* java堆也被成为GC堆
* java堆分为新生代和老年代。新生代又分为Eden，from Servivor，to Servivor。
* 线程共享的java堆可能划分出几个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB)
* java堆处于物理上不连续的空间中，只需要逻辑上是连续的即可。可以通过-Xmx和-Xms控制，当无法再扩展时，将会抛出OutOfMemoryError异常。

#### 对象的创建

普通java对象是一个什么样的创建过程呢？ （不包括Class对象和数组对象）

当遇到一个new关键字时，首先回去运行时常量池中查找是否已经存在一个类的符号引用，并且检查这个符号引用代表的类是否加载，验证，准备，解析和初始化过，如果没有则必须先执行相应的类加载过程。在类加载检查通过过后，接下来便是为新对象分配内存，为对象分配内存的任务就是将一块固定大小的内存空间从java堆中划分出来，有两种方法：指针碰撞和空闲列表方法。指针碰撞即维护的是两块空间，一块连续使用的空间，一块连续空闲的空间，中间分界的指针是一个指示器，把指示器向后移动一段对象大小的距离。 空闲列表需要维护一个列表，来记录哪些空间可以使用。

创建对象是十分频繁的操作，在多线程并发下也是不安全的。有两种解决方法：1. 控制多线程的并发 2. 每一个线程单独分配一小块内存（称为本地线程的内存缓冲Thread Local Alloction Buffer，TLAB），线程需要需要内存，就在线程自己的TLAB上分配，只有TLAB用完时才需要同步。

#### 对象的内存布局

对象分为三部分，对象头（Header)、实例数据（Instance Data）、和对齐填充（Padding）

对象头中包含两部分信息：

1. 对象自身运行时数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID,偏向时间戳等，这部分数据在32bit虚拟机中占32bit，在64bit虚拟机中占64bit，官方称“Mark Word”。为了节省空间，Mark Word被设计成非固定的数据结构以便在极小的空间内存储更多的信息。比如32bit虚拟机下：

   未锁定状态：25bit存储哈希值，4bit存储gc分代年龄，2bit存储锁标识位，1bit固定为0

   其他状态：

   ![1571039443563](/..\img\1571039443563.png)

2. 第二部分是类型指针，执行它的类元数据的指针。虚拟机通过这个来判断该对象属于哪个类的实例

### 2.4.3 方法区和运行时常量池溢出

jdk1.6之前，字符串常量池分配在方法区（永久代）中。jdk1.6之后字符串常量池改成放入堆中，以下代码执行时java堆异常。


```java
/**
 * VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>();
        //10MB的PermSize在integer范围内足够产生OOM了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
```

> 运行结果

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.lang.Integer.toString(Integer.java:403)
	at java.lang.String.valueOf(String.java:3099)
	at com.github.chuangkel.java_learn.base.jvm.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
```



## 垃圾回收器与内存分配策略



## 虚拟机性能监控与故障处理工具



## 调优案例分析与实战





两个线程直接有哪些通信方式，同享变量的方式？



# jvm基本原理

## jvm内存结构

* 线程私有：虚拟机栈（本地虚拟机栈），程序计数器
* 线程公共：堆，方法区

java堆划分为两个区域: 新生代(young)、老年代(old)

新生代又分为三个区域：eden,from survivor,to survivor

#### 虚拟机栈

> 会抛出两种异常：
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
>
> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。



局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这
个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变
量表的大小。

#### java堆

> 会抛出OutOfMemoryError异常。

#### 为什么要指定堆的初始最大值和最小值？

堆的大小用-Xms（初始堆大小）、-Xmx（最大堆大小）指定

新生代 eden:from:to = 8:1:1可以通过-XX:SurvivorRatio来指定

两种gc:minor gc和full gc (major gc)

eden+from作为新生代使用的区域，进行gc之后，判断存活对象大小是否小于to的大小，小于拷贝到to区，然后清除掉eden和from区域，并将还存活的对象的年龄+1，当达到15（默认）之后进入老年代  -XX:MaxTenuringThreshold可以设定进入老年代的年龄，对于大的对象也可以直接进入老年代。

## jvm内存模型

> 主内存+工作内存。硬件上的内存cpu寄存器、cpu缓存和主内存，物理内存和内存模型划分是交叉的关系。
>
> JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。

* 主内存	
  * 存放对象、类信息、静态变量
  * 包含了
* 工作内存
  * 存放方法局部变量，程序计数器信息的
  * 包含了

| 回收算法 | 思想 | 所用的地方 |
| -------- | ---- | ---------- |
| 标记复制 |      | 新生代     |
| 标记清除 |      | 老年代     |
| 标记整理 |      | 老年代     |
|          |      |            |

### 运行时常量池

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不 要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，**运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法**。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申 请到内存时会抛出OutOfMemoryError异常。 

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

 类和接口的全限定名（Fully Qualified Name） 

字段的名称和描述符（Descriptor） 

方法的名称和描述符

 Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。