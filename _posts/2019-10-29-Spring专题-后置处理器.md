---
layout:     post
title:		Spring专题
subtitle:   后置处理器
date:       2019-10-29
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - spring
---



# 后置处理器

### 有哪些钩子函数?（hook）

BeanFactoryPostProcessor和BeanPostProcessor是spring初始化对外暴露的扩展点，spring给了我们修改bean的机会比如生成bean的包装类，aop的底层实现也是通过这种方式实现的。

1. 后置处理器BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization钩子函数。**（在同一容器中对所有的bean的初始化都会进行回调）**

   Factory钩子函数被允许修改容器中已经实例化的bean，例如，检查标记接口或用代理包装bean。后置处理器居住在bean中，是bean实现特定的接口方法比如（BeanPostProcessor接口中的两个方法postProcessBeforeInitialization，postProcessAfterInitialization）或者标记接口来让后置处理器的方法出现在bean中。

   ```java
   public interface BeanPostProcessor {
      @Nullable
      default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
         return bean;
      }
   
      @Nullable
      default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
         return bean;
      }
   }
   ```

   实践demo:

   ```java
   public class MyProcessor implements BeanPostProcessor {
       @Override
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("在初始化之前调用...");
           return bean;
       }
       @Override
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("在初始化之后调用...");
           return bean;
       }
   }
   //XML文件配置
   <bean id="myProcessor" class="com.github.chuangkel.springdemo.Model.MyProcessor"/>
   //Main主类
   public static void main(String[] args) {
           ClassPathResource classPathResource = new ClassPathResource("bean.xml");
           DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();
           XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory);
           xmlBeanDefinitionReader.loadBeanDefinitions(classPathResource);
       //获取后置处理器
           MyProcessor myProcessor = (MyProcessor) defaultListableBeanFactory.getBean("myProcessor");
       //由于没有使用ApplicationContext（替我们做了）,这里需要手动添加后置处理器。
           defaultListableBeanFactory.addBeanPostProcessor(myProcessor);
           Person person = (Person) defaultListableBeanFactory.getBean("person");
           MyClass myClass = (MyClass) defaultListableBeanFactory.getBean("clazz");
   
   }
   /** 结果如下：
   在初始化之前调用...
   正在初始化...
   在初始化之后调用...
   17:06:20.045 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'clazz'
   在初始化之前调用...
   在初始化之后调用...
   /*
   ```

2. BeanFactoryPostProcessor的postProcessBeanFactory钩子函数，钩子函数允许对spring容器的bean定义和bean属性值适配的自定义修改。

   ```java
   @FunctionalInterface
   public interface BeanFactoryPostProcessor {
      void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
   }
   ```

   举个spring源码实现了BeanFactoryPostProcessor的例子：

   ```java
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      try {
         Properties mergedProps = mergeProperties();
         // Convert the merged properties, if necessary.
         convertProperties(mergedProps);
         // Let the subclass process the properties.
         processProperties(beanFactory, mergedProps);
      }
      catch (IOException ex) {
         throw new BeanInitializationException("Could not load properties", ex);
      }
   }
   ```

3. **BeanDefinitionRegistryPostProcessor**

