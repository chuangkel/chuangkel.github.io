---
layout:     post
title:		Spring专题
subtitle:   后置处理器
date:       2019-10-29
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - spring
---

## Aware接口

在bean实例化之后获取相应的上下文信息

BeanFactoryAware

BeanNameAware

ApplicationContextAware

ResourceLoaderAware

ServletContextAware

## 后置处理器

### 有哪些钩子函数?（hook）

BeanFactoryPostProcessor和BeanPostProcessor是spring初始化对外暴露的扩展点，spring给了我们修改bean的机会比如生成bean的包装类，aop的底层实现也是通过这种方式实现的。

1. 后置处理器BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization钩子函数。**（在同一容器中对所有的bean的初始化都会进行回调）**

   Factory钩子函数被允许修改容器中已经实例化的bean，例如，检查标记接口或用代理包装bean。后置处理器居住在bean中，是bean实现特定的接口方法比如（BeanPostProcessor接口中的两个方法postProcessBeforeInitialization，postProcessAfterInitialization）或者标记接口来让后置处理器的方法出现在bean中。

   ```java
   public interface BeanPostProcessor {
      @Nullable
      default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
         return bean;
      }
   
      @Nullable
      default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
         return bean;
      }
   }
   ```

   实践demo:

   ```java
   public class MyProcessor implements BeanPostProcessor {
       @Override
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("在初始化之前调用...");
           return bean;
       }
       @Override
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
           System.out.println("在初始化之后调用...");
           return bean;
       }
   }
   //XML文件配置
   <bean id="myProcessor" class="com.github.chuangkel.springdemo.Model.MyProcessor"/>
   //Main主类
   public static void main(String[] args) {
           ClassPathResource classPathResource = new ClassPathResource("bean.xml");
           DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();
           XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory);
           xmlBeanDefinitionReader.loadBeanDefinitions(classPathResource);
       //获取后置处理器
           MyProcessor myProcessor = (MyProcessor) defaultListableBeanFactory.getBean("myProcessor");
       //由于没有使用ApplicationContext（替我们做了）,这里需要手动添加后置处理器。
           defaultListableBeanFactory.addBeanPostProcessor(myProcessor);
           Person person = (Person) defaultListableBeanFactory.getBean("person");
           MyClass myClass = (MyClass) defaultListableBeanFactory.getBean("clazz");
   
   }
   /** 结果如下：
   在初始化之前调用...
   正在初始化...
   在初始化之后调用...
   17:06:20.045 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'clazz'
   在初始化之前调用...
   在初始化之后调用...
   /*
   ```

2. BeanFactoryPostProcessor的postProcessBeanFactory钩子函数，钩子函数允许对spring容器的bean定义和bean属性值适配的自定义修改。

   ```java
   @FunctionalInterface
   public interface BeanFactoryPostProcessor {
      void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
   }
   ```

   举个spring源码实现了BeanFactoryPostProcessor的例子：

   ```java
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      try {
         Properties mergedProps = mergeProperties();
         // Convert the merged properties, if necessary.
         convertProperties(mergedProps);
         // Let the subclass process the properties.
         processProperties(beanFactory, mergedProps);
      }
      catch (IOException ex) {
         throw new BeanInitializationException("Could not load properties", ex);
      }
   }
   ```

3. **BeanDefinitionRegistryPostProcessor**





## BeanPostProcessor

```java
class ApplicationContextAwareProcessor implements BeanPostProcessor {
 //postProcessBeforeInitialization 实现的目的，一般是扫描接口标记，怎么扫描呢，看当前bean（入参）是否实现了接口（bean instanceof ResourceLoaderAware） ，如果实现了，set需要感知的资源加载器。
    @Override
	@Nullable
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)){
			return bean;
		}

		AccessControlContext acc = null;

		if (System.getSecurityManager() != null) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareInterfaces(bean);
				return null;
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}
    //被调用的方法 
    private void invokeAwareInterfaces(Object bean) {
		if (bean instanceof EnvironmentAware) {
			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
		}
		if (bean instanceof EmbeddedValueResolverAware) {
			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
		}
		if (bean instanceof ResourceLoaderAware) {
			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
		}
		if (bean instanceof ApplicationEventPublisherAware) {
			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
		}
		if (bean instanceof MessageSourceAware) {
			((MessageSourceAware) bean).setMessageSource(this.applicationContext);
		}
		if (bean instanceof ApplicationContextAware) {
			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
		}
	}
 //postProcessAfterInitialization 一般用来用包装bean,用到了装饰器模式
    @Nullable
	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
}
```