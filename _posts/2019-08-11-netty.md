---
layout:     post
title:	netty
subtitle: 	netty
date:       2019-08-11
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# netty

bio（阻塞）nio（非阻塞） aio(异步非阻塞)



### AbstractInterruptibleChannel

```java
public int read(ByteBuffer dst) throws IOException {
    //...
    try {
        begin(); //为什么调用了implCloseChannel（）
        bytesRead = in.read(buf, 0, bytesToRead);
    } finally {
        end(bytesRead > 0);
    }
    //...
}
```



```java
protected final void begin() {
    if (interruptor == null) {
        interruptor = new Interruptible() {
                public void interrupt(Thread target) {
                    synchronized (closeLock) {
                        if (!open)
                            return;
                        open = false;
                        interrupted = target;
                        try {
                            AbstractInterruptibleChannel.this.implCloseChannel();
                        } catch (IOException x) { }
                    }
                }};
    }
    blockedOn(interruptor);//
    Thread me = Thread.currentThread();
    if (me.isInterrupted())
        interruptor.interrupt(me); //如果被中断 ，则停止线程
}
```





```java
protected final void end(boolean completed)
    throws AsynchronousCloseException
{
    blockedOn(null);
    Thread interrupted = this.interrupted;
    if (interrupted != null && interrupted == Thread.currentThread()) {
        interrupted = null;
        throw new ClosedByInterruptException();
    }
    if (!completed && !open)
        throw new AsynchronousCloseException();
}
```





### NIO

Channel（通道），Buffer（缓冲区），Selector（选择器）





### websocket

#### 轮询

定时向服务端发送请求，可能有更新数据，可能无数据返回。

#### 长轮询 long polling

客户端发起请求，服务端无更新数据时，hold住请求，阻塞请求，待有更新数据时再返回。期间一直保持着连接。读超时时间ReadTimeout比较长，有设置的必要。 请求返回或者超时断开，立即轮询。

ping/pong机制是怎么实现的？

