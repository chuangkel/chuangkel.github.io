---
layout:     post
title:	mysql索引
subtitle: 	mysql索引
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

# mysql索引

## 数据库优化具备的基础知识

> explain 只能解释select查询语句。select 查看查询语句的执行计划

### 执行计划实践

```mysql
CREATE TABLE `user_info` (
  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(50) NOT NULL DEFAULT '',
  `age`  INT(11)              DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `name_index` (`name`)
)
  ENGINE = InnoDB
  DEFAULT CHARSET = utf8;

INSERT INTO user_info (name, age) VALUES ('xys', 20);
INSERT INTO user_info (name, age) VALUES ('a', 21);
INSERT INTO user_info (name, age) VALUES ('b', 23);
INSERT INTO user_info (name, age) VALUES ('c', 50);
INSERT INTO user_info (name, age) VALUES ('d', 15);
INSERT INTO user_info (name, age) VALUES ('e', 20);
INSERT INTO user_info (name, age) VALUES ('f', 21);
INSERT INTO user_info (name, age) VALUES ('g', 23);
INSERT INTO user_info (name, age) VALUES ('h', 50);
INSERT INTO user_info (name, age) VALUES ('i', 15);
```



#### explain返回的字段：

* id  每一个select都会返回一个id
* select_type
  * simple ，表示此查询不包含 UNION 查询或子查询
  * primary，表示此查询是最外层的查询
  * union，
  * dependent union，
  * ...
* table
* partitions
* type 访问类型
  * null ：eg. select max() from ...
  
  * system/const ：where 后面=是常量
  
  * eq_ref 多表查询时，根据非唯一空索引进行查询
  
  * ref 多表查询时，根据非唯一非空索引进行查询
  
  * range 在索引上进行范围查找：当=,< ,> ,<=,>=,<>,<=>,in,between,is null
  
    * <=> 安全比较运算符，用来做 NULL 值的关系运算SELECT 1 <=> NULL, !(1 <=> NULL);// 结果0,1
  
    * != 和 not in 不走索引
  
    * @用来标识用户变量，@@用来标识系统变量 
  
  * index 遍历索引树
  
  * all 全表扫描
  
  * 比较：ALL < index < range ~ index_merge < ref < eq_ref < const < system<null
* possible_keys 查询中可能使用的索引。possible_keys为null，说明没有where条件时优化器无法通过索引检索数据。
* key 实际中使用到的索引
* key_len 实际索引长度
* rows此次查询所需读取的行数。越小越好
* extra 
  * Using index 在查询树中就可查询到数据，没有操作数据表。
  * Using index condition 需要回表。
  * Using temporary使用了临时表，一般出现于join,排序，分组的情况。
  * Using filesort 没有使用索引排序，进行了额外的排序。可以对排序字段加索引。
    * 下面的例子：dim_id有索引（主键），dim_name无索引
      * EXPLAIN select * from hg_tdimension order by dim_id; // type:index,extra:null
      * EXPLAIN select * from hg_tdimension order by dim_name; // type:all,extra:Using filesort



### 数据库优化的思路

* 加索引
* 语句优化
* 分库分表

### 索引类型

> B+Tree结构都可以用在MyISAM和InnoDB上

例子：主键id,二级索引plname

| id   | plname | ranking |
| :--- | :----- | :------ |
| 15   | C      | 2       |
| 16   | Java   | 1       |
| 18   | Php    | 6       |
| 23   | C#     | 5       |
| 26   | C++    | 3       |
| 29   | Ada    | 17      |
| 50   | Go     | 12      |
| 52   | Lisp   | 15      |

- 聚簇索引(主键索引) 索引数据和存储数据是一起的。

  > InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = xxx"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。
  >
  > 每个表只能有一个聚簇索引。聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。

![img](/../img/聚簇索引.png)

- 非聚簇索引 索引数据和存储数据是分离的。

  > MyISAM的是非聚簇索引，B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址，主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主索引和辅助索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，主索引和辅助索引的两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
  >
  > InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，这是聚簇索引。(所以聚簇索引的主键不能过长)

![img](/../img/聚簇索引和非聚簇索引.png)

- 辅助索引（二级索引）
  - 普通索引
  - 唯一索引
  - 前缀索引。原则：降低重复的索引值。索引值重复性越低，查询效率也就越高，节省空间。
    - alter table test add index(name(9)); -- 以前9位字符构建索引（注：实践）

![img](/../img/辅助索引.png)

#### 什么是索引覆盖？

> 覆盖索引（covering index）指一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要根据辅助索引得到的主键去查询聚集索引中的记录，也称索引覆盖。
>
> ```mysql
> explain select sql_no_cache count(staff_id) from t1 --会全表扫描
> alter table t1 add key(staff_id); -- 添加之后上面的sql会走索引 staff_id.前提条件是，查询返回的字段数足够少.
> -------------------------
> --未加索引之前，会回表查询，extra执行计划列：using index condition (inventory_id是二级索引，实践：inventory_id是主键的情况 )
> explain select sql_no_cache rental_date from t1 where inventory_id<80000
> --加索引，extra执行计划列：using index
> alter table t1 add key(inventory_id,rental_date);
> ```

#### 覆盖索引的优势？

* select的列在索引中
* where条件中要包含索引列或复合索引的前导列

### 为什么加索引？

> 索引是针对查询，索引是B树或者B+树的数据结构。两大好处：
>
> * 根据索引返回只需要的数据
> * 从索引中直接返回数据

### 怎么加索引？



#### 扩展：

> SQL_NO_CACHE 使查询不走缓存 Select SQL_NO_CACHE * from geek where c=3 order by b limit 1;

* limit 5 //相当于limit 0 5，返回第1到5条记录
* limit 10,15 //返回第11-15条记录