---
layout:     post
title:	线程池
subtitle: 	
date:       2019-12-24
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# Thread

线程是一种CPU利用的基本单元

**Thread**

> 线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。
>
> * 根据操作系统的不同（Windows/Unix/Linux/其他），他们所支持的线程底层实现和操作效果也是不尽相同的。不过一个操作系统支持的线程至少会有四种状态：就绪、执行、阻塞和终结。**线程在四种状态下进行切换，都是要消耗不少的CPU计算能力的**。
>* 线程在创建时，操作系统不会为这个线程分配独立的资源（除了必要的数据支撑）。一个应用程序（进程）下的所有线程，都是共享这个应用程序（进程）中的资源，例如这个应用程序的CPU资源、I/O资源、内存资源。
> * 现在基本上主流操作系统都支持多线程实现。即一个应用程序中（一个进程中），可以创建多个线程。一个应用程序下，各个线程间都可以进行通讯、可以进行状态互操作。且一个进程中，至少有一个线程存在。



```java
//ip: java.lang.Thread#interrupt
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();
    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag ，修改中断标识
            b.interrupt(this);//Q:这里会阻塞线程吗？ A:不会，整个方法只是修改线程的中断标识，线程进行的操作若无法响应中断时，则会继续执行线程。
            return;
        }
    }
    interrupt0();
}
```

new Thread()：创建java.lang.Thread对象
• 继承父线程daemon, priority, contextClassLoader
• 没有真正创建线程，进行了系统调用（补）

thread.start()
• thread.start()概述：创建线程（?)，并启动线程
• 线程模型概述：

![1568272526093](/..\img\pthread.png)



******

![1568272653919](/..\img\threadstart.png)

**线程状态转换图**

> 源码里面定义的状态和下图有出入（原理上），把就绪和运行中合并成了RUNNABLE，把BLOCKED拆分成了BLOCKED、WAITING和TIMED_WAITING三种状态。

下面的图应该有些问题，有哪些问题呢？



![1567751701058](/../img/thread五种状态.png)

> 源码：

```java
// java.lang.Thread.State
    /**
     * A thread state.  A thread can be in one of the following states:
     * <ul>
     * <li>{@link #NEW}<br>
     *     A thread that has not yet started is in this state.
     *     </li>
     * <li>{@link #RUNNABLE}<br>
     *     A thread executing in the Java virtual machine is in this state.
     *     </li>
     * <li>{@link #BLOCKED}<br>
     *     A thread that is blocked waiting for a monitor lock
     *     is in this state.
     *     </li>
     * <li>{@link #WAITING}<br>
     *     A thread that is waiting indefinitely for another thread to
     *     perform a particular action is in this state.
     *     </li>
     * <li>{@link #TIMED_WAITING}<br>
     *     A thread that is waiting for another thread to perform an action
     *     for up to a specified waiting time is in this state.
     *     </li>
     * <li>{@link #TERMINATED}<br>
     *     A thread that has exited is in this state.
     *     </li>
     * </ul>
     *
     * <p>
     * A thread can be in only one state at a given point in time.
     * These states are virtual machine states which do not reflect
     * any operating system thread states.
     *一个线程在一个时间点只能有一个状态。 这6种状态是Jvm的线程状态，并且不和操作系统线程状态映射。即不是操作系统的状态。
     * @since   1.5
     * @see #getState
     */
    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * <ul>
         *   <li>{@link Object#wait() Object.wait} with no timeout</li>
         *   <li>{@link #join() Thread.join} with no timeout</li>
         *   <li>{@link LockSupport#park() LockSupport.park}</li>
         * </ul>
         *
         * <p>A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called <tt>Object.wait()</tt>
         * on an object is waiting for another thread to call
         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
         * that object. A thread that has called <tt>Thread.join()</tt>
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * <ul>
         *   <li>{@link #sleep Thread.sleep}</li>
         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
         *   <li>{@link #join(long) Thread.join} with timeout</li>
         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
         * </ul>
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
```

**源码里面的六种状态**

> 一个线程在任意一个时间点只能有且只有其中一种状态

- NEW：创建后尚未启动的线程处于这种状态
- RUNNABLE
  - 可运行：线程对象创建后，调用了该对象的start()方法，等待被线程调度选中获取cpu的使用权
  - 运行中（Running）：可运行状态(runnable)的线程获得了cpu 时间片（timeslice），执行程序代码
- BLOCKED：线程等待进入同步区域（synchronized）。`阻塞状态`与`等待状态`的区别：阻塞状态在等待着获取到一个排它锁；等待状态是在等待一段时间或唤醒动作的发生
- WAITING：不会被分配CPU执行时间，等待被其他线程显式地唤醒
  - Object.wait()
  - Thread.join()
  - LockSupport.park()
- TIMED_WAITING：无须等待被其他线程显式地唤醒，在一定时间之后由操作系统自动唤醒
  - Thread.sleep(long)  不会释放object's monitor，在同步块中注意使用
  - Object.wait(long) 必须持有object's monitor才能调用改方法，否则会报IllegalMonitorStateException，调用之后释放object's monitor
  - Thread.join(long) 同步方法（Synchronized）中调用了wait()
  - LockSupport.parkNanos() 不会释放锁(不是object's monitor)
  - LockSupport.parkUntil() 
- TERMINATED：线程已经结束执行

**Thread.yield()**

> yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 
> 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。
**interrupt()的理解**

```java
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
	
   /**如果抛出异常，会清除中断状态 interrupted status
 	 * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;
```

> interrupt() 只改变中断状态，不会终止线程执行

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            while (true){} //endless loop
        });
        thread.start();
        thread.interrupt(); //只改变中断状态，并没有结束线程
}
//使用姿势
public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            while (!Thread.currentThread().isInterrupted()){
                System.out.println("sub thread is over");
            }
        });
        thread.start();
        Thread.sleep(100);
        thread.interrupt();
}
```

> thread.interrupt()中断时，若thread处于挂起，则会抛出中断异常

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            try {
                Thread.sleep(100); //抛出异常之前将中断状态置为false
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().isInterrupted());
            }
        });
        thread.start();
        thread.interrupt(); //将中断状态置为true
}
```

**interrupted()  VS  isInterrupted()**

```java
public static boolean interrupted() {
       return currentThread().isInterrupted(true);//会清除中断状态
}
public boolean isInterrupted() {
       return isInterrupted(false);//不会清除中断状态
}
private native boolean isInterrupted(boolean ClearInterrupted);
```

**总结：哪些情况下会清除中断状态？**

* 用interrupted()来判断当前中断状态时，返回当前中断状态，并置中断状态为false 。本质上是 isInterrupted(true) 
* 调用interrupt()方法时，当前线程处于挂起状态(什么是挂起状态？），会清除中断状态并抛出异常（什么异常呢？，如下情形会使线程挂起：
  * Object#wait() 、Object#wait(long) 、Object#wait(long, int)
  * Thread.currentThread().join() 、Thread.currentThread().join(long millis) 、Thread.currentThread().join(long millis, int nanos)
  * Thread.sleep(long) 、Thread.sleep(long, int)
  * If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel} then the channel will be closed
  * If this thread is blocked in a {@link java.nio.channels.Selector} then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value

实践： com.github.chuangkel.java.juc.ThreadInterruptDemo

```java
public class ThreadInterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                System.out.println("进入 sleep ...");
                /**
                 *Thread#sleep()可以随时响应中断标识的变化，同时抛出{@link InterruptedException}异常。
                 * 在捕获异常的地方可以控制线程的结束
                 */
                Thread.sleep(1500000);
                System.out.println("子线程新来了, 若被中断应该不会打印该行...");
            } catch (InterruptedException e) {
                System.out.println("这里发生了中断异常");
            }
        });
        //启动之后才能中断
        //thread.interrupt();
        thread.start();
        //主线程 sleep 1 s 保证子线程进入sleep
        Thread.sleep(1000);
        System.out.println("开始中断...");
        /**
         * 1. {@link Thread#interrupt()}只是修改了中断标识，并未停止线程
         * 2. 已经进入sleep的线程可以被interrupt。
         * 3. 中断进入sleep线程时,sleep线程能立刻响应。
         */
        thread.interrupt();
        System.out.println("已经中断...");
        thread.join();
        //中断sleep线程 它立刻响应了 立刻返回了
        System.out.println("游戏结束...");
    }
}
```

**论是否响应中断**

线程被中断，即修改了线程的中断标识，线程并不会结束运行（中断线程不会影响线程的运行，只是改了中断标识而已）。在于线程运行和结束完全在于自身代码和中断标识的配合，若使用了wait()、join()、sleep()、lockInteruptLy()方法（在调用期间\调用时候会判断中断标识），则会清除中断标识并抛出异常。线程自身代码亦可以判断中断标识（Thread.isInterrupted(boolean)），来进行相关的代码处理，包括结束线程。

**thread实例.join()源码分析**

```java
public final void join() throws InterruptedException {
    join(0);
}
```

> 子线程调用join，子线程.isAlive()，主线程.wait(0) 。
>
> ```
> The specified amount of real time has elapsed, more or less.  If
>  {@code timeout} is zero, however, then real time is not taken into
>  consideration and the thread simply waits until notified.
>  //如果timeout为0 wait直到被通知
> ```

```java
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;
    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }
    if (millis == 0) {
        while (isAlive()) { //测试this线程是否存活
            wait(0); //让当前线程（主线程）挂起 ，0 直接等待通知
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

> thread.join()方法的缺点：主线程会一直运行就绪挂起，运行就绪挂起三种状态之间流转，比较耗费资源。

### volatile 

> volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。
>
> volatile是如何实现禁止指令重排优化的？
>
> 内存屏障(Memory Barrier），是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。

#### happen-before原则

> happen-before 理解成“先于什么发生”

* 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。

* 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。

* volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。

* happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。

* 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。

* 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。

* 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。

* 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。

### Thread.sleep()、Object.wait()和LockSupport.park()的区别

![](/../img/挂起线程.png)

#### Condition 的await()会释放锁，但是纯粹调用park()不会释放锁

> 不加锁调用await会报IlegalMonnitorEeception

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

## 线程池


> 核心线程数满了工作队列没满会往工作队列中添加，工作队列满了但是没有超过最大线程数会直接执行。工作队列满了同时达到最大线程数之后根据拒绝策略来工作。线程池运行线程数已经到达最大线程数了，这个时候新提交的任务该根据拒绝策略来执行

1. 达到最大线程数之后如何退回到核心线程数？
2. 核心线程数会不会减少?会减少到0吗?(这两个问题的答案都在getTask()这个方法里面)

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
		//设置了核心线程数超时或者当前有效线程大于核心线程数
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

### 线程池拒绝策略

**AbortPolicy**：A handler for rejected tasks that throws a {@code RejectedExecutionException}，（**默认拒绝策略**）

**CallerRunsPolicy**：A handler for rejected tasks that runs the rejected task directly in the calling thread of the {@code execute} method, unless the executor has been shut down, in which case the task is discarded（**当达到最大线程数之后，由调用线程执行**）

**DiscardOldestPolicy**：A handler for rejected tasks that discards the oldest unhandled request and then retries {@code execute}, unless the executor is shut down, in which case the task is discarded

**DiscardPolicy**：A handler for rejected tasks that silently discards the rejected task



### 线程池状态转换

1. RUNNING -> SHUTDOWN

On invocation of shutdown(), perhaps implicitly in finalize()

2. (RUNNING or SHUTDOWN) -> STOP

On invocation of shutdownNow()

3. SHUTDOWN -> TIDYING

When both queue and pool are empty

4. STOP -> TIDYING

When pool is empty

5. TIDYING -> TERMINATED

When the terminated() hook method has completed

扩展：

Callable、Future和FutureTask 、RunnableFuture

线程可以中断，其他线程可以中断当前线程，线程中断不能停止线程的执行，只是修改了中断标识。Thread#sleep()、Thread#join()、Object#wait()、ReentrantLock#lockInterruptibly()才会响应中断抛出异常。

## 父子线程上下文





# ThreadLocal

ThreadLocal存在的必要，如果是基本数据类型，即线程私有的，无需什么ThreadLocal。由于java内存结构，对象存放在公共区堆，线程A new一个对象，线程B中可以对A创建的对象进行修改，这是肯定的，若存在该对象的类型需要每个线程私有对象实例，ThreadLocal就是为这种情况开发的吧（我主管看法）。

ThreadLocal只是对一种类型进行封装，并不存储对象实例，对象实例真正存放在线程本地ThreadLocal.ThreadLocalMap变量中，即Map结构中，所以一个线程可以存放多种类型的实例数据，存储在同一个Map中，数据存放在Value中，key为ThreadLocal实例。 可以定义多个ThreadLocal相同类型。

ThreadLocal.ThreadLocalMap是Thread类中的属性之一，可以值是弱引用，GC时会回收，但是该ThreadLocal 是new出来的，所以有强引用指向它。

ThreadLocalMap 是存放在数组中的，扩容是 2 * oldLen ，初始长度是16，扩容后长度和初始长度都和HashMap一样。

问题：

1. 为什么ThreadLocal使用的是弱引用，并且在Map的key值上使用了弱引用？



父子线程上下文传递：

```java
public class InheritableThreadLocalDemo {
    static InheritableThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>();
    static ThreadLocal<String> threadLocal = new ThreadLocal<>();
    public static void main(String[] args) {
        inheritableThreadLocal.set("父线程 : ThreadLocal 会传递到子线程");
        threadLocal.set("父线程 : ThreadLocal 不会传递到子线程");
        Thread thread1 = new Thread(() -> {
            System.out.println(inheritableThreadLocal.get());
            System.out.println(threadLocal.get());
        });
        thread1.start();
    }
}
//输出：
//父线程 : ThreadLocal 会传递到子线程
//null
```




```java
//java.lang.Thread#threadLocals
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;

/*
 * Inheritable ThreadLocal values pertaining to this thread. This map is
 * maintained by the InheritableThreadLocal class.
 */
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

#### 强引用 软引用 弱引用  虚引用

ThreadLocal 弱引用是key

如果不remove会产生大对象，线程池执行完任务可能并没有销毁，执行下一个任务的时候会还能读取得到。

弱引用通过isEnQueued()方法判断是否在标记队列，是否被垃圾回收器标记

注意：

使用线程池，线程使用结束后 需remove ThreadLocal，否则或干扰后面任务的执行。



### ThreadLocal源码分析

#### java.lang.ThreadLocal#set

```java
// 首先会获取当前线程的Map数据结构，再进行数据set
public void set(T value) {
    Thread t = Thread.currentThread(); //获取当前线程
    ThreadLocalMap map = getMap(t); //获取当前线程本地变量
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value); //当前线程ThreadLocal实例为空，创建一个，若父线程有继承，则会继承父线程的InheriableThreadLocal
}
	//java.lang.ThreadLocal#createMap
 void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue); //this 是ThreadLocal的实例，也是Map的key,即虚引用。
    }
```

#### java.lang.ThreadLocal.ThreadLocalMap#remove

```java
/**  Remove the entry for key. */
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear(); //java.lang.ref.Reference#referent = null
            expungeStaleEntry(i);
            return;
        }
    }
}
```



### WeakHashMap源码分析





### ThreadLocal案例





#### PageHelper实现分页原理

>  PageHelper.offsetPage(PAGE_NUM, PAGE_SIZE) （页码，每页显示的数量）。
>
>  实际是在 ThreadLocal中设置了分页参数，之后在查询执行的时候，获取当线程中的分页参数，执行查询的时候通过拦截器在sql语句中添加分页参数，之后实现分页查询，查询结束后在 finally 语句中清除ThreadLocal中的查询参数。

com.github.pagehelper.page.PageMethod#setLocalPage

```java
protected static final ThreadLocal<Page> LOCAL_PAGE = new ThreadLocal<Page>();

    /**
     * 设置 Page 参数
     *
     * @param page
     */
    protected static void setLocalPage(Page page) {
        LOCAL_PAGE.set(page);
    }
```

逻辑分页



物理分页

PageInterceptor拦截器拦截query()查询方法

分页的参数放在LocalThread里面



##### 过滤器(Filter)



拦截器（Interceptor）

> 使用反射机制实现的

​	

##### 反射机制

##### jdk自带的InvocationHandler

> 只能实现接口实现类的代理

```java
public interface Animal {
    void eat();
}
```

```java
public class Cat implements Animal {
    /**
     * java 自带的动态代理 需要实现接口
     */
    @Override
    public void eat() {
        System.out.println("cat is eatting");
    }
}
```

> 自定义InvocationHandler的实现

```java
public class CatInvocationHandler implements InvocationHandler {
    private Object object;

    CatInvocationHandler(Object object) {
        this.object = object;
    }

    public Object newProxyInstance() {
        return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("调用eat()之前");
        Object result =  method.invoke(object, args);
        System.out.println("调用eat()之后");
        return result;
    }
}
```

> 调用被动态代理的接口方法

```java
public class Main {
    public static void main(String[] args) {
        Cat cat = new Cat();
        CatInvocationHandler d = new CatInvocationHandler(cat);
        Animal animal = (Animal) d.newProxyInstance();
        animal.eat();
    }
}
```

> 结果:
> 调用eat()之前
> cat is eatting
> 调用eat()之后

##### cglib的MethodInterceptor

> 可以对接口和类进行代理





## 趣题实践

```java
public class ThreadExecutionDemo {
    private static void action(){
        System.out.printf("当前线程%s\n",Thread.currentThread());
    }
    public static void main(String[] args) {
        Thread t1 = new Thread(ThreadExecutionDemo::action,"t1");
        Thread t2 = new Thread(ThreadExecutionDemo::action,"t2");
        Thread t3 = new Thread(ThreadExecutionDemo::action,"t3");
        threadStartWait(t1);
        threadStartWait(t2);
        threadStartWait(t3);
    }
    private static void threadStartWait(Thread thread) {

        if (Thread.State.NEW.equals(thread.getState())) {
            thread.start();
        }
        while (thread.isAlive()) {
            synchronized (thread) {
                try {
                    //thread.wait(); //谁来唤醒它
                    thread.wait(0); //谁来唤醒它,直到该线程销毁返回
                    //thread.join();
                    /**
                     * thread.wait() = thread.wait(0) 永久等待 直到被唤醒
                     * thread.join(); 本质上是调用wait
                     */
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



# ThreadPoolExecutor

### 问题

1. 为什么有线程池的存在？
2. ThreadPoolExecutor是什么？
3. 线程池的数据结构？
4. 线程池原理是什么？怎么管理多线程的？
5. 线程池的状态有哪些？
6. 线程池六大参数分析? 用阿里规范创建线程池
7. 线程池是怎么实现线程复用的 ？
8. 线程一开始就是创建了核心线程数数量的线程吗？
9. 线程池是命令模式的应用？
10. 为什么Worker要实现同步器？

### 数据结构

```java
//任务阻塞队列，用来存放任务，在任务大于核心线程数情况下, 入队到阻塞队列中
private final BlockingQueue<Runnable> workQueue;
//加入Worker到线程池workers并发控制
private final ReentrantLock mainLock = new ReentrantLock();
/**
 * Set containing all worker threads in pool. Accessed only when
 * holding mainLock. 线程池用来存放线程的集合
 */
private final HashSet<Worker> workers = new HashSet<Worker>();
/**
 * Wait condition to support awaitTermination
 */
private final Condition termination = mainLock.newCondition();
//追踪到达的最大池大小， 记录峰值
private int largestPoolSize;
/**
 * Counter for completed tasks. Updated only on termination of
 * worker threads. Accessed only under mainLock.
 */
private long completedTaskCount;
private volatile ThreadFactory threadFactory;
/**
 * Handler called when saturated or shutdown in execute.
 */
private volatile RejectedExecutionHandler handler;
/**
 * Timeout in nanoseconds for idle threads waiting for work.
 * Threads use this timeout when there are more than corePoolSize
 * present or if allowCoreThreadTimeOut. Otherwise they wait
 * forever for new work.
 */
private volatile long keepAliveTime;
/**
 * If false (default), core threads stay alive even when idle.
 * If true, core threads use keepAliveTime to time out waiting
 * for work.
 */
private volatile boolean allowCoreThreadTimeOut;
/**
 * Core pool size is the minimum number of workers to keep alive
 * (and not allow to time out etc) unless allowCoreThreadTimeOut
 * is set, in which case the minimum is zero.
 */
private volatile int corePoolSize;
/**
 * Maximum pool size. Note that the actual maximum is internally
 * bounded by CAPACITY.
 */
private volatile int maximumPoolSize;
/**
 * The default rejected execution handler 默认拒绝策略AbortPolicy()
 */
private static final RejectedExecutionHandler defaultHandler =
    new AbortPolicy();
```

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
//线程池容量存储在ctl低29位
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
// runState is stored in the high-order bits 线程运行状态存储在ctl高3位
//11100000000000000000000000000000 高位111
private static final int RUNNING    = -1 << COUNT_BITS;
//00000000000000000000000000000000 高位000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
//00100000000000000000000000000000 高位001
private static final int STOP       =  1 << COUNT_BITS;
//01000000000000000000000000000000 高位010
private static final int TIDYING    =  2 << COUNT_BITS;
//01100000000000000000000000000000 高位011
private static final int TERMINATED =  3 << COUNT_BITS;
```

> execute执行任务，会加入到队列里面吗？

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
  	//线程池状态和线程池线程数量都存储在ctl中
    int c = ctl.get();
    //线程池线程数量小于核心线程数
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //线程池线程数量大于核心线程数，isRunning(c)判断线程池状态，if true，则添加到阻塞队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
       //到了这里，线程池状态是RUNNING且核心线程数已满且插入到阻塞队列成功
        if (! isRunning(recheck) && remove(command))
            //线程池不在运行且移除任务成功 那么按照拒绝策略处理
            reject(command);
        else if (workerCountOf(recheck) == 0)
            //1. 线程池在运行 且运行线程数为0
            //2. 线程池不在运行且移除任务失败 且运行线程数为0
            //在上面两种情况下，应该开一个线程来执行阻塞队列里的任务
            addWorker(null, false);// 为什么任务是null和false（不是核心）
    }
    //任务队列满了，直接运行，if 直接运行失败，按照拒绝策略处理
    else if (!addWorker(command, false))
        reject(command);
}
```

> addWorker是干什么的？ 直接运行任务

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        // Check if queue empty only if necessary.  
        //! (rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()) 等效于
        //   rs != SHUTDOWN || firstTask != null ||  workQueue.isEmpty() 线程关闭从这里退出
        //firstTask为null的情况是为了执行任务队列里的任务。
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;
		// 到了这里，说明线程池状态是RUNNING或者线程池状态是SHUTDOWN且新加的任务是nul且任务队列不为空
        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry; //若新增运行线程数+1成功，则跳出retry循环
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs) 
                continue retry; //线程池状态改变了，重来一遍
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
	//到了这里，新增ctl的线程数成功
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
				//线程池是RUNNING状态 或 线程池是SHUTDOWN且加入的任务为空
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w); //Worker加入到线程池
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start(); //启动线程
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

## Worker(线程+任务)分析

### worker数据结构

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{   //继承了Runnable和同步器
    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread; 
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);//工厂方法创建线程
    }
    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }
  //...
}
```

> getTask是干什么的？ 从阻塞任务队列获取任务，若队列为空，则阻塞当前线程。

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        // Check if queue empty only if necessary.
        //rs >= SHUTDOWN不是运行状态 rs>=STOP不是RUNNING和SHUTDOWN状态，队列是空
        //ShutDown状态并且队列是空 或者 是STOP状态
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;//返回null结束当前线程
        }
        int wc = workerCountOf(c);
        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null; //返回null结束当前线程
            continue;
        }
        try {
            //poll等待keepAalived若队列中仍没有元素，返回
            //take一直等待任务队列中元素有效 
            //若在等待期间，线程池关闭（会修改中断标识），这抛出中断异常。
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

### 调用的类外(Worker类之外)方法

> 怎么样让线程一直运行的？怎样复用线程的？即通过运行阻塞队列的任务，若阻塞队列为空，则阻塞当前线程。

翻译：Worker类主要保留了对正在执行任务中的线程们的控制，以及一些统计和监控。这个类合理地继承了AbstractQueuedSynchronizer同步器，为了简化获取和释放锁在每个任务执行前后，这可以防止一些中断，这些中断的目的是唤醒正在等待任务的工作线程，而不是中断正在运行的任务。它实现了一个简单的**非重入互斥独占锁**而不是用ReentrantLock重入锁，因为我们不想工作线程在执行任务期间被重入锁当他们调用线程池方法的时候，比如setCorePoolSize。此外，为了防止线程在开始运行任务之前被中断，我们设置了state为-1，并且在执行任务之前清除他为0在runWorker。

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        //循环 让线程一直运行，除非设置了存活时间过后回收。任务队列中获取任务时，任务为空会阻塞线程
        //若存活线程为0的情况，会新建一个Worker(null,false)来执行队列中的任务。
        while (task != null || (task = getTask()) != null) {
            //这里不会抛出中断异常，lock实现忽略了中断了的。目的是调用shutdown时阻塞tryLock()方法，保证任务执行期间不被中断，同时阻塞线程池的关闭等待线程执行完成。
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            //如果不进入if判断内部的话清除了中断信号
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
    //线程池是Running和shutdown,原来是中断的中断信号被清除了,重新判断线程池不是Running和shutdown
                // 线程池不是Running和shutdown 且 当前线程wt没有被中断
                wt.interrupt(); //上面的情况需要中断当前线程
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //在运行的线程中调用run方法执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

## 线程池的关闭方法

shutdown 不在接收新的任务进入阻塞队列，继续处理正在运行的任务和阻塞队列的任务。

shutdownNow 不在接收新的任务进入阻塞队列，尝试中断正在运行的线程（修改中断标识）和不再处理阻塞队列的任务并将任务列表返回。

1. **shutdown** 。线程池shutdown 停止向阻塞队列里面提交任务。

   问题：shutdown有什么功能？

   将线程池状态改为shutdown，拒绝向阻塞队列提交任务。修改空闲线程的中断标识(怎么知道是空闲线程的呢？看代码)。 这个时候会继续执行阻塞队列里的任务。

   问题：怎么做到停止向阻塞队列里面提交任务的，看下面的

   ```java
   private boolean addWorker(Runnable firstTask, boolean core) {
       retry:
       for (;;) {
           int c = ctl.get();
           int rs = runStateOf(c);
    	//! (rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()) 等效于
       //   rs != SHUTDOWN || firstTask != null ||  workQueue.isEmpty() 线程shutdown关闭从          这里退出。firstTask为null的情况是为了执行任务队列里的任务。
           if (rs >= SHUTDOWN &&
               ! (rs == SHUTDOWN &&
                  firstTask == null &&
                  ! workQueue.isEmpty()))
               return false;
           //......
       }
   }
   ```

   ```java
   public void shutdown() {
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           checkShutdownAccess();
           advanceRunState(SHUTDOWN);
           interruptIdleWorkers();
           onShutdown(); // hook for ScheduledThreadPoolExecutor
       } finally {
           mainLock.unlock();
       }
       tryTerminate();
   }
   ```

   修改空闲的线程中断标识

   ```java
   private void interruptIdleWorkers(boolean onlyOne) {
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           for (Worker w : workers) {
               Thread t = w.thread;
               //线程没有被中断 并且 不在执行(尝试获取锁成功，因为是不可重入锁)
               if (!t.isInterrupted() && w.tryLock()) { 
                   //从这里可以判断是空闲线程，空闲线程会阻塞住在获取任务的时候。这里会发生中断异常。
                   try {
                       t.interrupt();
                   } catch (SecurityException ignore) {
                   } finally {
                       w.unlock();
                   }
               }
               if (onlyOne)
                   break;
           }
       } finally {
           mainLock.unlock();
       }
   }
   ```

   这个方法是为了在调用shutdown之后占用线程的锁，使线程池中的线程阻塞住。

   ```java
   protected boolean tryAcquire(int unused) {
       if (compareAndSetState(0, 1)) {
           setExclusiveOwnerThread(Thread.currentThread());
           return true;
       }
       return false;
   }
   ```

   它是阻塞在任务队列中了，这个时候关闭线程池，这个阻塞的线程会state置成1，当获得任务的lock的时候会被阻塞呀 

2. **shutdownNow** 试图停止激活的正在执行的任务，停止对阻塞队列中任务的处理，并返回等待的任务的List，这些任务将被从阻塞队列移除。该方法不等待任务到终止。任务如果无法响应中断或许永远不会停止。

   问题：shutdownNow做了那些事：1. 将线程池状态改成STOP  2. 中断workers中的所有线程  3. 不会执行阻塞队列里的任务了（shutdown会），而是返回阻塞队列中的等待的任务。

   ```java
   public List<Runnable> shutdownNow() {
       List<Runnable> tasks;
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           checkShutdownAccess();
           advanceRunState(STOP);
           interruptWorkers();
           tasks = drainQueue();
       } finally {
           mainLock.unlock();
       }
       tryTerminate();
       return tasks;
   }
   ```

   ```java
   private void advanceRunState(int targetState) {
       for (;;) {
           int c = ctl.get();
           if (runStateAtLeast(c, targetState) ||
               ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
               //ctlOf(targetState, workerCountOf(c))将高位和低位拼在一起
               break;
       }
   }
   ```

   中断所有线程

   ```java
   private void interruptWorkers() {
       final ReentrantLock mainLock = this.mainLock;
       mainLock.lock();
       try {
           for (Worker w : workers)
               w.interruptIfStarted();
       } finally {
           mainLock.unlock();
       }
   }
   ```

   ```java
   void interruptIfStarted() {
       Thread t; // state为-1禁止中断
       if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
           try {
               t.interrupt();
           } catch (SecurityException ignore) {
           }
       }
   }
   ```

3. **awaitTermination** 该方法会等待任务到终止。

## 用阿里规范创建线程池

### 问题

1. 核心线程数量怎么确定？

> 自定义线程工厂（参考jdk实现）

```java
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
                              Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
                      poolNumber.getAndIncrement() +
                     "-thread-";
    }

    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}
```



## Executors创建线程池（不推荐）

> newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

> newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

> newScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```

> newSingleThreadExecutor，为什么不用当个线程代替只有一个线程的线程池？

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```



ForkJoinPool

java.util.concurrent.CompletableFuture



## ScheduledThreadPoolExecutor延时队列、间隔时间执行

#### 问题

1. ScheduledThreadPoolExecutor使用到的数据结构？

   > 使用数据结构堆来作为队列的，同时又是使用数组来作为堆的数据结构，为什么要使用堆呢？

2. 使用堆的数据结构，怎么样实现排序的呢？有什么方便之处吗？

3. 堆的数据结构是什么样的？

4. 怎么实现定时执行任务的呢？

### DelayedWordQueue(线程池ThreadPoolExecutor定义)

   #### 堆数据结构

   - 大顶堆 父节点大于左右节点，左节点大于右节点。
   - 小顶堆 父节点是小于左右节点，左节点要小于右节点。

   > 延时任务队列，队列的元素先后顺序在元素加入的时候就进行了排序，排序依据是任务的time值。入队和出队操作需同步控制，因为线程池空闲线程可能不止一个，存在多线程取队列任务的情况。

   ```java
static class DelayedWorkQueue extends AbstractQueue<Runnable>
       implements BlockingQueue<Runnable> {
       private static final int INITIAL_CAPACITY = 16;//队列的初始容量16
       private RunnableScheduledFuture<?>[] queue =
           new RunnableScheduledFuture<?>[INITIAL_CAPACITY];
       private final ReentrantLock lock = new ReentrantLock();
       private int size = 0;
       private Thread leader = null;
       private final Condition available = lock.newCondition();
       //...
    }
   ```

   > 队列(数组)扩容，队列容量上限为Integer.MAX_VALUE，每次增长原队列容量的一半。

   ```java
private void grow() {
    int oldCapacity = queue.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // grow 50%
    if (newCapacity < 0) // overflow
        newCapacity = Integer.MAX_VALUE;
    queue = Arrays.copyOf(queue, newCapacity);
}
   ```
   >添加元素到队列，需并发控制，比较任务time值。堆数据结构的上浮。

   ```java
public boolean offer(Runnable x) {
    if (x == null)
        throw new NullPointerException();
    RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        int i = size;
        if (i >= queue.length)
            grow();
        size = i + 1;
        if (i == 0) {
            queue[0] = e;
            setIndex(e, 0);
        } else {
            siftUp(i, e);
        }
        if (queue[0] == e) {
            leader = null;
            available.signal();
        }
    } finally {
        lock.unlock();
    }
    return true;
}
   ```

   > 设置任务在堆中的下标idx。

   ```java
   private void setIndex(RunnableScheduledFuture<?> f, int idx) {
       if (f instanceof ScheduledFutureTask)
           ((ScheduledFutureTask)f).heapIndex = idx;
   }
   ```


> 堆下沉。

   ```java
   private void siftDown(int k, RunnableScheduledFuture<?> key) {
       int half = size >>> 1;
       while (k < half) {
           int child = (k << 1) + 1;
           RunnableScheduledFuture<?> c = queue[child];
           int right = child + 1;
           if (right < size && c.compareTo(queue[right]) > 0)
               c = queue[child = right];
           if (key.compareTo(c) <= 0)
               break;
           queue[k] = c;
           setIndex(c, k);
           k = child;
       }
       queue[k] = key;
       setIndex(key, k);
   }
   ```

> 堆上浮

   ```java
   private void siftUp(int k, RunnableScheduledFuture<?> key) {
       while (k > 0) {
           int parent = (k - 1) >>> 1;
           RunnableScheduledFuture<?> e = queue[parent];
           if (key.compareTo(e) >= 0)
               break;
           queue[k] = e;
           setIndex(e, k);
           k = parent;
       }
       queue[k] = key;
       setIndex(key, k);
   }
   ```

> 任务比较函数，根据ScheduledFutureTask.time来比较先后执行顺序

```java
public int compareTo(Delayed other) {
    if (other == this) // compare zero if same object
        return 0;
    if (other instanceof ScheduledFutureTask) {
        ScheduledFutureTask<?> x = (ScheduledFutureTask<?>)other;
        long diff = time - x.time;
        if (diff < 0)
            return -1;
        else if (diff > 0)
            return 1;
        else if (sequenceNumber < x.sequenceNumber)
            return -1;
        else
            return 1;
    }
    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);
    return (diff < 0) ? -1 : (diff > 0) ? 1 : 0;
}
```

### ScheduleThreadPoolExecutor线程池方法分析

> 

```java
public ScheduledFuture<?> schedule(Runnable command,
                                   long delay,
                                   TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    RunnableScheduledFuture<?> t = decorateTask(command,
        new ScheduledFutureTask<Void>(command, null,
                                      triggerTime(delay, unit)));
    delayedExecute(t);
    return t;
}
```




> scheduleAtFixedRate延时initialDelay执行，每隔period周期执行任务，若隔period时间周期前一次任务还没执行完成，则等待前一次任务执行完成之后再开始重新执行任务。若上个任务提前执行完成，则需等待时间到两次任务开始执行间隔时间周期为period。

```java
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                              long initialDelay,
                                              long period,
                                              TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (period <= 0)
        throw new IllegalArgumentException();
    ScheduledFutureTask<Void> sft =
        new ScheduledFutureTask<Void>(command,
                                      null,
                                      triggerTime(initialDelay, unit),
                                      unit.toNanos(period));//传入周期
    RunnableScheduledFuture<Void> t = decorateTask(command, sft);
    sft.outerTask = t;
    delayedExecute(t);
    return t;
}
```

> scheduleWithFixedDelay 任务执行的间隔时间为delay，等待任务执行之后再等待delay时长，再重新执行任务，不管任务执行的时间长短，只管两次执行任务的间隔时间，即前一次完成时间和后一次的开始时间的间隔。

```java
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                 long initialDelay,
                                                 long delay,
                                                 TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (delay <= 0)
        throw new IllegalArgumentException();
    ScheduledFutureTask<Void> sft =
        new ScheduledFutureTask<Void>(command,
                                      null,
                                      triggerTime(initialDelay, unit),
                                      unit.toNanos(-delay));//why？
    RunnableScheduledFuture<Void> t = decorateTask(command, sft);
    sft.outerTask = t;
    delayedExecute(t);
    return t;
}
```


### 怎么实现重复执行任务的

> ScheduledFutureTask延时（间隔执行）任务定义类

   ```java
private class ScheduledFutureTask<V>
           extends FutureTask<V> implements RunnableScheduledFuture<V> {
       /** Sequence number to break ties FIFO */
       private final long sequenceNumber;
       /** The time the task is enabled to execute in nanoTime units */
       private long time;
       /**
        * Period in nanoseconds for repeating tasks.  A positive
        * value indicates fixed-rate execution.  A negative value
        * indicates fixed-delay execution.  A value of 0 indicates a
        * non-repeating task. 正值:固定速率循环 负值：固定延时循环 0:不循环
        */
       private final long period;
       /** The actual task to be re-enqueued by reExecutePeriodic */
       RunnableScheduledFuture<V> outerTask = this;
   	//记录当前任务在堆中的index下标
       int heapIndex;
       //...
    }
   ```