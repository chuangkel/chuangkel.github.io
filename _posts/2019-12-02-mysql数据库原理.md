---
layout:     post
title:	mysql数据库原理
subtitle: 	mysql数据库原理
date:       2019-09-02
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

#  Mysql数据库原理

- 连接器层 
  - 功能：连接处理，授权认证，安全
- 服务器层
  - 查询缓存
  - 解析器
  - 优化器
  - 执行器
  - binlog日志
- 存储引擎层
  - InnoDB
  - MyISAM
  - Memory



* 基于行的复制



* 基于语句的复制



* 异步复制

![img](/../img/数据库异步复制.png)



* 半同步复制

![img](/../img/数据半同步复制.png)



复制过程中的线程

* 主库开启dump thread复制响应从库IO thread请求

* 从库开启IO thread，负责连接主库，请求binlog,将binlog写入relay-log(中继日志)
* 从库开启 Sql thread，负责执行relay-log事件



#### bin log和redo log及undo log的区别？

> bin log 先于redo log产生，可以在my.cnf配置文件中配置相关参数

* bin log
  * 在服务层产生，针对大多数存储引擎
  * 全量拷贝，事务所有的操作。T事务增加一行row，然后删除row，会记录下操作过程。
* sync_binlog参数：控制bin log 同步到磁盘的频率
    * sync_binlog默认值0，不主动同步
    * sync_binlog值为1，每写一次bin log 同步一次磁盘，最安全
  
* redo log
  * 在存储引擎层，是innodb产生的
  * 事务终态拷贝，具有幂等性，T事务增加一行row，然后删除row，相当于记录不会修改。
  * redo log包括内存缓冲日志（redo log buffer）、磁盘持久化日志（redo log file）两部分。内存缓冲日志持久化到磁盘通过参数innodb_flush_log_at_trx_commit 来控制
    * innodb_flush_log_at_trx_commit 为1，事务提交立刻提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据安全，耗时较长）
    * innodb_flush_log_at_trx_commit 为0，每秒钟提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短）
    * innodb_flush_log_at_trx_commit 为2，事务提交立刻提交redo log buffer 到 os buffer，并且每秒调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短，可以防止mysqld 进程崩溃造成的数据丢失）
* fsync()系统调用，将内核缓存提交到磁盘

![img](/../img/fsync用户空间到内核空间)

* undo log

  > undo log提供回滚和多个行版本控制(MVCC)，事务失败回滚时，会借助undo log进行回滚。
  >
  > * 回滚：undo log 是逻辑日志（redo log 是物理日志），undo log 会记录相反的操作（delete 一条记录会产生一条insert记录的日志，update会产生一条相反的update日志）。
  >
  > * 多个行版本控制(MVCC)：某一行被锁定而需要读取时，从undo log日志中解析出上一个版本记录的数据，实现非锁定一致性读取。



### InnoDB页结构

> InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB。一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。InnoDB有多种页，索引页，Undo页，Inode页，系统页，BloB页等。

![img](/../img/innodb页结构图.jpg)

#### mysql索引和页的关系？

B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为了达到这个目的，磁盘按需读取，要求每次都会预读的长度一般为页的整数倍。而且数据库系统将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。并把B-tree中的m值设的非常大，就会让树的高度降低，有利于一次完全载入。

#### 磁盘块和索引

![](../img/B+%E6%A0%91%E7%A3%81%E7%9B%98%E5%9D%97.jpg)

如图所示是 `B+ Tree` 的数据结构。是由一个一个的磁盘块组成的树形结构，每个磁盘块由数据项和指针组成。

> 所有的数据都是存放在叶子节点，非叶子节点不存放数据。索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。

以磁盘块1为例，指针 P1 表示小于17的磁盘块，P2 表示在 17~35 之间的磁盘块，P3 则表示大于35的磁盘块。比如要查找数据项99，首先将磁盘块1 load 到内存中，发生 1 次 IO。接着通过二分查找发现 99 大于 35，所以找到了 P3 指针。通过P3 指针发生第二次 IO 将磁盘块4加载到内存。再通过二分查找发现大于87，通过 P3 指针发生了第三次 IO 将磁盘块11 加载到内存。最后再通过一次二分查找找到了数据项99。由此可见，如果一个几百万的数据查询只需要进行三次 IO 即可找到数据，那么整个效率将是非常高的。观察树的结构，发现查询需要经历几次 IO 是由树的高度来决定的，而树的高度又由磁盘块，数据项的大小决定的。磁盘块越大，数据项越小那么树的高度就越低。这也就是为什么索引字段要尽可能小的原因。

#### 为什么innodb表最大支持64TB?

innodb的页号是一个32bit int类型数值，一页大小默认为16KB，那么最多有2^32 * 16kb =  64TB

#### 页、磁盘块与扇区联系

* 概念
  * 扇区：磁盘的最小存储单位
  * 磁盘块：文件系统读写数据的最小单位
  * 页：内存的最小存储单位
* 联系
  * 一个磁盘块由连续几个（2^n）扇区组成
  * 页的大小为磁盘块大小的2^n倍
* 查看
  * 页大小查看： getconf PAGE_SIZE，常见为4K
  * 磁盘块大小查看：stat /boot/|grep 'IO Block'，常见为4K
  * 扇区大小查看：fdisk -l，常见为512Byte

