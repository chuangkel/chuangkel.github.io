---
layout:     post
title:	java虚拟机
subtitle: 	第三部分：虚拟机执行子系统
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# 第三部分：虚拟机执行子系统

## 类文件结构

* 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）
* 实现语言无关性的基础仍然是**虚拟机和字节码存储格式**。Java虚拟机不和包括Java在内的任何语言绑定，**java虚拟机只与“Class文件”这种特定的二进制文件格式所关联**，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，**虚拟机并不关心Class的来源是何种语言**。
* Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。
*  **任何一个Class文件都对应着唯一一个类或接口的定义信息**，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。
* Class文件是一组以**8位字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
* 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有**两种数据类型：无符号数和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。
* **无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
* **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

### 魔数与Class文件的版本



### 常量池

javac JavapTest.java

javap -verbose JavaTest.class

```java
public class JavapTest {
    int a = 1;
    int aa = 2;
}
```

```
  MD5 checksum 58b88c85c197d544ff05d0dd49d96580
  Compiled from "JavapTest.java"
public class com.github.chuangkel.java_learn.base.bases.JavapTest
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #4                          // com/github/chuangkel/java_learn/base/bases/JavapTest
  super_class: #5                         // java/lang/Object
  interfaces: 0, fields: 2, methods: 1, attributes: 1
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#16         // com/github/chuangkel/java_learn/base/bases/JavapTest.a:I
   #3 = Fieldref           #4.#17         // com/github/chuangkel/java_learn/base/bases/JavapTest.aa:I
   #4 = Class              #18            // com/github/chuangkel/java_learn/base/bases/JavapTest
   #5 = Class              #19            // java/lang/Object
   #6 = Utf8               a
   #7 = Utf8               I
   #8 = Utf8               aa
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               SourceFile
  #14 = Utf8               JavapTest.java
  #15 = NameAndType        #9:#10         // "<init>":()V
  #16 = NameAndType        #6:#7          // a:I
  #17 = NameAndType        #8:#7          // aa:I
  #18 = Utf8               com/github/chuangkel/java_learn/base/bases/JavapTest
  #19 = Utf8               java/lang/Object
{
  int a;
    descriptor: I
    flags: (0x0000)

  int aa;
    descriptor: I
    flags: (0x0000)

  public com.github.chuangkel.java_learn.base.bases.JavapTest();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: aload_0
        10: iconst_2
        11: putfield      #3                  // Field aa:I
        14: return
      LineNumberTable:
        line 9: 0
        line 10: 4
        line 11: 9
}
SourceFile: "JavapTest.java"
```





## 虚拟机类加载机制

> - 代码编译的结果是把机器码转换成了字节码（class文件），是存储格式的一小步，确实编程语言进步的一大步。
> - 类加载机制就是将字节码（class文件）加载进虚拟机。



* class文件描述的各种信息，最终都需要加载到虚拟机中才能运行和使用。
* 虚拟机的类加载机制：虚拟机把描述类的数据加载进内存，并对数据进行校验 ，转换解析并进行初始化，最终形成java虚拟机可以使用的java类型，这就是java虚拟机的类加载机制。

* 类的加载过程：加载、验证、准备、解析、初始化



### 类加载过程

类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。

#### 加载

这是类加载过程的第一个阶段，工程师对程序的控制性也最强，可以定义Class字节码文件的来源（网络、数据库或文件）。类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。自定义类加载器只需重写一个类加载器的loadClass()方法。

把Class二进制文件加载进方法区。

#### 验证

对方法区的Class二进制文件进行校验。

#### 准备

准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的**初始值**“通常情况”下是数据类型的**零值**，假设一个类变量的定义为

```java
public static int VALUE = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于**类构造器＜clinit＞()**方法之中，所以把value**赋值为123**的动作将在**初始化阶段**才会执行。

在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：

```java
public final static int VALUE = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在这个阶段，类装入器装入类所引用的其他所有类。可以用许多方式引用类：超类、接口、字段、方法签名、方法中使用的本地变量。

#### 初始化

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：**初始化阶段**是**执行类构造器＜clinit＞()**方法的过程。

＜clinit＞()方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块（static{}块）**中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```java
public class Test{
    static{
    i=0；//给变量赋值可以正常编译通过
    System.out.print（i）；//这句编译器会提示"非法向前引用"
    }
    static int i=1；
}
```

＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。由于父类的＜clinit＞()方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的静态语句块操作**。

```java
static class Parent{
    public static int A=1；
    static{
    A=2；
    }
}
static class Sub extends Parent{
    public static int B=A；
    }
    public static void main（String[]args）{
    System.out.println（Sub.B）；
}
```

＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。

虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

```java
static class DeadLoopClass{
    static{
        /*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/
        if（true）{
            System.out.println（Thread.currentThread（）+"init DeadLoopClass"）；
            while（true）{
            }
        }
    }
}
public static void main（String[]args）{
    Runnable script=new Runnable（）{
        public void run（）{
            System.out.println（Thread.currentThread（）+"start"）；
            DeadLoopClass dlc=new DeadLoopClass（）；
            System.out.println（Thread.currentThread（）+"run over"）；
        }
    }；
    Thread thread1=new Thread（script）；
    Thread thread2=new Thread（script）；
    thread1.start（）；
    thread2.start（）；
}
//Thread[Thread-0，5，main]start
//Thread[Thread-1，5，main]start
//Thread[Thread-0，5，main]init DeadLoopClass
```

到此，类已经完整装入，可以使用了。

类装入的方式有两种 —— *显式* 或 *隐式*，两者之间有些细微差异。

*显式* 类装入发生在使用以下方法调用装入的类的时候：

- `cl.loadClass()`（`cl` 是 `java.lang.ClassLoader` 的实例）
- `Class.forName()`（启动的类装入器是当前类定义的类装入器）

当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

*隐式* 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

类的装入通常组合了显式和隐式类装入。例如，类装入器可能先显式地装入一个类，然后再隐式地装入它引用的所有类。



* Java是一门静态语言，通常class在编译的时候就已经生成了，为什么有时候我们还想在运行时动态生成class呢？因为在有些时候得在运行时为一个类动态创建子类。比如编写一个ORM框架，如何得知一个简单的JavaBean是否被用户修改过呢？

其实`UserProxy`实现起来很简单，就是创建一个`User`的子类，覆写所有`setXxx()`方法，做个标记就可以了：


  但是这个`UserProxy`就必须在运行时动态创建出来了，因为编译时ORM框架根本不知道`User`类。

现在问题来了，动态生成字节码，难度有多大？

如果我们要自己直接输出二进制格式的字节码，在完成这个任务前，必须先认真阅读[JVM规范第4章](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)，详细了解class文件结构。估计读完规范后，两个月过去了。

所以，第一种方法，自己动手，从零开始创建字节码，理论上可行，实际上很难。

第二种方法，使用已有的一些能操作字节码的库，帮助我们创建class。

目前，能够操作字节码的开源库主要有[CGLib](https://github.com/cglib/cglib)和[Javassist](http://jboss-javassist.github.io/javassist/)两种，它们都提供了比较高级的API来操作字节码，最后输出为class文件。

比如CGLib，典型的用法如下：  

换一个思路，如果我们能创建`UserProxy.java`这个源文件，再调用Java编译器，直接把源码编译成class，再加载进虚拟机，任务完成！

毕竟，创建一个字符串格式的源码是很简单的事情，就是拼字符串嘛，高级点的做法可以用一个模版引擎。

如何编译？

Java的编译器是`javac`，但是，在很早很早的时候，Java的编译器就已经用纯Java重写了，自己能编译自己，行业黑话叫“自举”。从Java 1.6开始，编译器接口正式放到JDK的公开API中，于是，我们不需要创建新的进程来调用`javac`，而是直接使用编译器API来编译源码。

使用起来也很简单：

```
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
int compilationResult = compiler.run(null, null, null, '/path/to/Test.java');
```

 

这么写编译是没啥问题，问题是我们在内存中创建了Java代码后，必须先写到文件，再编译，最后还要手动读取class文件内容并用一个ClassLoader加载。

> 有木有更简单的方法？

有！

其实Java编译器根本不关心源码的内容是从哪来的，你给它一个`String`当作源码，它就可以输出`byte[]`作为class的内容。

所以，我们需要参考Java Compiler API的文档，让Compiler直接在内存中完成编译，输出的class内容就是`byte[]`。

代码改造如下：

> 除了写ORM用之外，还能干什么？

* 可以用它来做一个Java脚本引擎？



### 