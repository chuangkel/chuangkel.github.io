---
layout:     post
title:	JVM专题
subtitle: 	第三部分：虚拟机执行子系统
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# 第三部分：虚拟机执行子系统

## 类文件结构

类文件结构中组成部分的排列顺序是**魔术和Class文件的版本，常量池，访问标志，类索引父类索引与接口索引集合，字段表集合，方法表集合，属性表集合**

* 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）
* 实现语言无关性的基础仍然是**虚拟机和字节码存储格式**。Java虚拟机不和包括Java在内的任何语言绑定，**java虚拟机只与“Class文件”这种特定的二进制文件格式所关联**，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，**虚拟机并不关心Class的来源是何种语言**。
* Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。
*  **任何一个Class文件都对应着唯一一个类或接口的定义信息**，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。
* Class文件是一组以**8位字节为基础单位的二进制流**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
* 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有**两种数据类型：无符号数和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。
* **无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
* **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

### 魔数与Class文件的版本



### 常量池

javac JavapTest.java

javap -verbose JavaTest.class

```java
public class JavapTest {
    int a = 1;
    int aa = 2;
}
```

```
  MD5 checksum 58b88c85c197d544ff05d0dd49d96580
  Compiled from "JavapTest.java"
public class com.github.chuangkel.java_learn.base.bases.JavapTest
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #4                          // com/github/chuangkel/java_learn/base/bases/JavapTest
  super_class: #5                         // java/lang/Object
  interfaces: 0, fields: 2, methods: 1, attributes: 1
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#16         // com/github/chuangkel/java_learn/base/bases/JavapTest.a:I
   #3 = Fieldref           #4.#17         // com/github/chuangkel/java_learn/base/bases/JavapTest.aa:I
   #4 = Class              #18            // com/github/chuangkel/java_learn/base/bases/JavapTest
   #5 = Class              #19            // java/lang/Object
   #6 = Utf8               a
   #7 = Utf8               I
   #8 = Utf8               aa
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               SourceFile
  #14 = Utf8               JavapTest.java
  #15 = NameAndType        #9:#10         // "<init>":()V
  #16 = NameAndType        #6:#7          // a:I
  #17 = NameAndType        #8:#7          // aa:I
  #18 = Utf8               com/github/chuangkel/java_learn/base/bases/JavapTest
  #19 = Utf8               java/lang/Object
{
  int a;
    descriptor: I
    flags: (0x0000)

  int aa;
    descriptor: I
    flags: (0x0000)

  public com.github.chuangkel.java_learn.base.bases.JavapTest();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: aload_0
        10: iconst_2
        11: putfield      #3                  // Field aa:I
        14: return
      LineNumberTable:
        line 9: 0
        line 10: 4
        line 11: 9
}
SourceFile: "JavapTest.java"
```

常量池可以分成两部分，字面量和符号引用。每个类型都是一个表，由u结构或u和表结构构成。每种常量池的结构的命名都是以_info结尾的，表示是一个表结构。

字面量：文本字符串和final常量。

符号引用：类和接口符号引用、方法符号引用、字段符号引用。

常量池的分类：CONSTANT_Utf8_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Double_info、CONSTANT_String_info（字节码中的，在运行时存放在堆中）、CONSTANT_Class_info、CONSTANT_Methodref_info、CONSTANT_Fieldref_info、CONSTANT_Interface_Method_info、CONSTANT_NameAndType_info(字段和字段类型对应关系常量池)、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_Invoke_Dynamic_info。

CONSTANT_Utf8_info是作为其他常量池表结构中的一部分(基础部分)，即其他的常量池比如CONSTANT_Class_info中指向了CONSTANT_Utf8_info中的地址。

![1569652816366](/../img/1569652816366.png)

### 访问标识

常量池之后紧接着是两个字节的访问标识(assecc flags)，用于描述改字节码文件是类还是接口，和访问的权限（public或者是default包默认访问级别）是否是final,是否是abstract等。

![1569653164983](/..\img\1569653164983.png)

### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2的数据，而接口索引集合是一组u2的数据。类索引为例，它指向的是常量池的CONSTANT_Class_info表里的数据行a,该数据a再指向常量池的CONSTANT_Utf8_info里面的数据行。父类索引用于确定这个类的全限定名，没有继承默认的父类为Object，Object的父类索引为空。

### 字段表集合

![1569657050063](/..\img\1569657050063.png)

字段类型

字段的修饰符 public、private、protected,默认包类型,；static;final;transient;voliate;

![1569653997069](/..\img\1569653997069.png)



### 方法表集合

方法表结构

![1569656980205](/..\img\1569656980205.png)

方法的修饰符 private,protected,public;synchronized;final;static;

![1569657010832](/..\img\1569657010832.png)

### 属性表集合

#### Code属性

Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。整个class文件分为元数据和代码，这个代码就是code索性，可见其重要性。

![1569682510429](/..\img\1569682510429.png)

1. **attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”**，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。

2. **max_stack代表了操作数栈（Operand Stacks）深度的最大值**。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（StackFrame）中的操作栈深度。

3. **max_locals代表了局部变量表所需的存储空间**。在这里，max_locals的单位是**Slot**,Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。**方法参数（包括实例方法中的隐藏参数“this”）**、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、**方法体中定义的局部变量都需要使用局部变量表来存放**。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。
4. **code_length和code用来存储Java源程序编译后生成的字节码指令**。code_length代表字节码长度，**code是用于存储字节码指令的一系列字节流**。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个**u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令**。

Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。

#### Execption属性



## 虚拟机类加载机制

> - 代码编译的结果是把机器码转换成了字节码（class文件），是存储格式的一小步，确实编程语言进步的一大步。
> - 类加载机制就是将字节码（class文件）加载进虚拟机。



* class文件描述的各种信息，最终都需要加载到虚拟机中才能运行和使用。
* 虚拟机的类加载机制：虚拟机把描述类的数据加载进内存，并对数据进行校验 ，转换解析并进行初始化，最终形成java虚拟机可以使用的java类型，这就是java虚拟机的类加载机制。

* 类的加载过程：加载、验证、准备、解析、初始化



### 类加载过程

类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。

#### 加载

这是类加载过程的第一个阶段，工程师对程序的控制性也最强，可以定义Class字节码文件的来源（网络、数据库或文件）。类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。自定义类加载器只需重写一个类加载器的loadClass()方法。

把Class二进制文件加载进方法区。

#### 验证

对方法区的Class二进制文件进行校验。

#### 准备

准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的**初始值**“通常情况”下是数据类型的**零值**，假设一个类变量的定义为

```java
public static int VALUE = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于**类构造器＜clinit＞()**方法之中，所以把value**赋值为123**的动作将在**初始化阶段**才会执行。

在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：

```java
public final static int VALUE = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在这个阶段，类装入器装入类所引用的其他所有类。可以用许多方式引用类：超类、接口、字段、方法签名、方法中使用的本地变量。

#### 初始化

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：**初始化阶段**是**执行类构造器＜clinit＞()**方法的过程。

＜clinit＞()方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块（static{}块）**中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```java
public class Test{
    static{
    i=0；//给变量赋值可以正常编译通过
    System.out.print（i）；//这句编译器会提示"非法向前引用"
    }
    static int i=1；
}
```

＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。由于父类的＜clinit＞()方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的静态语句块操作**。

```java
static class Parent{
    public static int A=1；
    static{
    A=2；
    }
}
static class Sub extends Parent{
    public static int B=A；
    }
    public static void main（String[]args）{
    System.out.println（Sub.B）；
}
```

＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。

虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

```java
static class DeadLoopClass{
    static{
        /*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/
        if（true）{
            System.out.println（Thread.currentThread（）+"init DeadLoopClass"）；
            while（true）{
            }
        }
    }
}
public static void main（String[]args）{
    Runnable script=new Runnable（）{
        public void run（）{
            System.out.println（Thread.currentThread（）+"start"）；
            DeadLoopClass dlc=new DeadLoopClass（）；
            System.out.println（Thread.currentThread（）+"run over"）；
        }
    }；
    Thread thread1=new Thread（script）；
    Thread thread2=new Thread（script）；
    thread1.start（）；
    thread2.start（）；
}
//Thread[Thread-0，5，main]start
//Thread[Thread-1，5，main]start
//Thread[Thread-0，5，main]init DeadLoopClass
```

到此，类已经完整装入，可以使用了。

类装入的方式有两种 —— *显式* 或 *隐式*，两者之间有些细微差异。

*显式* 类装入发生在使用以下方法调用装入的类的时候：

- `cl.loadClass()`（`cl` 是 `java.lang.ClassLoader` 的实例）
- `Class.forName()`（启动的类装入器是当前类定义的类装入器）

当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

*隐式* 类装入发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

类的装入通常组合了显式和隐式类装入。例如，类装入器可能先显式地装入一个类，然后再隐式地装入它引用的所有类。



* Java是一门静态语言，通常class在编译的时候就已经生成了，为什么有时候我们还想在运行时动态生成class呢？因为在有些时候得在运行时为一个类动态创建子类。比如编写一个ORM框架，如何得知一个简单的JavaBean是否被用户修改过呢？

其实`UserProxy`实现起来很简单，就是创建一个`User`的子类，覆写所有`setXxx()`方法，做个标记就可以了：


  但是这个`UserProxy`就必须在运行时动态创建出来了，因为编译时ORM框架根本不知道`User`类。

现在问题来了，动态生成字节码，难度有多大？

如果我们要自己直接输出二进制格式的字节码，在完成这个任务前，必须先认真阅读[JVM规范第4章](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)，详细了解class文件结构。估计读完规范后，两个月过去了。

所以，第一种方法，自己动手，从零开始创建字节码，理论上可行，实际上很难。

第二种方法，使用已有的一些能操作字节码的库，帮助我们创建class。

目前，能够操作字节码的开源库主要有[CGLib](https://github.com/cglib/cglib)和[Javassist](http://jboss-javassist.github.io/javassist/)两种，它们都提供了比较高级的API来操作字节码，最后输出为class文件。

比如CGLib，典型的用法如下：  

换一个思路，如果我们能创建`UserProxy.java`这个源文件，再调用Java编译器，直接把源码编译成class，再加载进虚拟机，任务完成！

毕竟，创建一个字符串格式的源码是很简单的事情，就是拼字符串嘛，高级点的做法可以用一个模版引擎。

如何编译？

Java的编译器是`javac`，但是，在很早很早的时候，Java的编译器就已经用纯Java重写了，自己能编译自己，行业黑话叫“自举”。从Java 1.6开始，编译器接口正式放到JDK的公开API中，于是，我们不需要创建新的进程来调用`javac`，而是直接使用编译器API来编译源码。

使用起来也很简单：

```
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
int compilationResult = compiler.run(null, null, null, '/path/to/Test.java');
```

 

这么写编译是没啥问题，问题是我们在内存中创建了Java代码后，必须先写到文件，再编译，最后还要手动读取class文件内容并用一个ClassLoader加载。

> 有木有更简单的方法？

有！

其实Java编译器根本不关心源码的内容是从哪来的，你给它一个`String`当作源码，它就可以输出`byte[]`作为class的内容。

所以，我们需要参考Java Compiler API的文档，让Compiler直接在内存中完成编译，输出的class内容就是`byte[]`。

代码改造如下：

> 除了写ORM用之外，还能干什么？

* 可以用它来做一个Java脚本引擎？



### 