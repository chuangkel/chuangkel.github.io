---
clayout:     post
title:		JUC专题
subtitle: 	 
date:       2019-12-24
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# AbstractQueuedSynchronizer同步器

> Head是Node.thread == null的节点，并不属于同步器队列

### 问题

1. 同步器是什么，使用场景有哪些？

   ```
   Provides a framework for implementing blocking locks and related
   * synchronizers (semaphores, events, etc) that rely on
   * first-in-first-out (FIFO) wait queues.  This class is designed to
   * be a useful basis for most kinds of synchronizers that rely on a
   * single atomic {@code int} value to represent state. Subclasses
   * must define the protected methods that change this state, and which
   * define what that state means in terms of this object being acquired
   * or released.  Given these, the other methods in this class carry
   * out all queuing and blocking mechanics. Subclasses can maintain
   * other state fields, but only the atomically updated {@code int}
   * value manipulated using methods {@link #getState}, {@link
   * #setState} and {@link #compareAndSetState} is tracked with respect
   * to synchronization.
   ```

   > AQS同步器是一个框架，为了实现阻塞锁和与阻塞锁关联的同步器（synchronizer），比如共享信号量（semaphores）等，它们依赖于一个先进先出的等待队列。AQS同步器作为大多数同步器的基类。

2. 同步器的数据结构？

3. 同步器中的ConditionObject类解析。

4. 什么是共享模式和独占模式？ 有什么区别？

5. 使用aqs实现自己的锁？

6. 什么时候唤醒后继者呢？

7. 重入是怎么实现的？

  ​    


### 同步队列

> 同步队列以链表方式，具有共享模式和独占模式
>
> sync队列和condition队列

```java
static final class Node {
    //用同一个对象 来标识线程获取的锁是共享的，在已占用的情况下，其他线程的共享模式可以进入锁
    static final Node SHARED = new Node();
    static final Node EXCLUSIVE = null; //标识该节点的线程获取的锁是独占的
    static final int CANCELLED =  1; //标识当前节点的线程已取消
    static final int SIGNAL    = -1;//唤醒下一个节点，什么时候唤醒呢？
    static final int CONDITION = -2;//正在等待什么条件？
    static final int PROPAGATE = -3;//标识在共享模式下面需要传播，怎么传播？
    volatile int waitStatus;//取值 CANCELLED、SIGNAL、CONDITION、PROPAGATE
    volatile Node prev;//同步队列中元素的上一个节点
    volatile Node next;//同步队列中元素的下一个节点
    volatile Thread thread; //入队列时的当前线程
    Node nextWaiter; //标识下一个节点的模式
    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode; //标识当前节点的模式
        this.thread = thread;
    }
}
```

#### waitStatus属性表

| waitStatus    | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| SIGNAL(-1)    | 当前节点线程的继任者处于被阻塞状态，当前线程在释放或取消时，必须unpark（启动）它的继任者。 |
| CANCELLED(1)  | 当前节点线程因为中断或者超时，被标识为CANCELLED。            |
| CONDITION(-2) | 当前节点线程处于condition队列中。nextWaiter存储condition队列中的后继节点 |
| PROPAGATE(-3) | 当前节点线程把共享消息传递给其他节点。                       |
| 0             | 当前节点线程处于sync队列中。                                 |



AQS共享模式和独占模式有什么区别

共享模式实现了多线程并发读，阻塞写，读线程释放锁之后才能读

独占模式实现了写线程阻塞读写线程

## 方法汇总

### 供Lock接口调用（代理）的方法

| 方法                                           | 说明                         | 调用者/使用者                                     |
| ---------------------------------------------- | ---------------------------- | ------------------------------------------------- |
| final void acquire(int arg)                    | 独占模式下获取锁，忽略中断   |                                                   |
| final boolean release(int arg)                 | 独占模式下释放锁             |                                                   |
| final void acquireInterruptibly(int arg)       | 独占模式下获取锁，可响应中断 |                                                   |
| final void acquireSharedInterruptibly(int arg) | 共享模式下获取锁，可响应中断 |                                                   |
| final void acquireShared(int arg)              | 共享模式下获取锁，忽略中断   | TwinsLock、Semaphore、ReentrantReadWrite.ReadLock |
| final boolean releaseShared(int arg)           | 共享模式下释放锁             |                                                   |

### 需子类实现的方法

> 子类实现AQS同步器过程中需调用getState()、setState(int newState)和compareAndSetState(int expect, int update)来操作锁状态

| 方法                                        | 说明                                               |
| ------------------------------------------- | -------------------------------------------------- |
| protected boolean tryAcquire(int arg)       | 在独占模式下尝试获取锁，会操纵锁状态来实现获取逻辑 |
| protected boolean tryRelease(int arg)       | 在独占模式下释放锁，会操纵锁状态                   |
| protected int tryAcquireShared(int arg)     | 在共享模式下尝试获取锁                             |
| protected boolean tryReleaseShared(int arg) | 在共享模式下释放锁                                 |
| protected final boolean isHeldExclusively() | 在独占模式下，查询当前线程是否持有锁               |

## 独占模式和共享模式的区别

* 获取锁
  * 共享模式
  * 独占模式

* 释放锁
	* 共享模式：doReleaseShared()
	* 独占模式：release()
* 都调用了如下的代码


## 独占模式

> 释放独占模式的操作

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```


## 共享模式



## 子类需实现的方法

* int tryAcquireShared(int arg) 用共享模式获取锁，



## Node

```java
static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1;
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1;
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3;

    /**
     * Status field, taking on only the values:
     *   SIGNAL:     The successor of this node is (or will soon be)
     *               blocked (via park), so the current node must
     *               unpark its successor when it releases or
     *               cancels. To avoid races, acquire methods must
     *               first indicate they need a signal,
     *               then retry the atomic acquire, and then,
     *               on failure, block.
     *   CANCELLED:  This node is cancelled due to timeout or interrupt.
     *               Nodes never leave this state. In particular,
     *               a thread with cancelled node never again blocks.
     *   CONDITION:  This node is currently on a condition queue.
     *               It will not be used as a sync queue node
     *               until transferred, at which time the status
     *               will be set to 0. (Use of this value here has
     *               nothing to do with the other uses of the
     *               field, but simplifies mechanics.)
     *   PROPAGATE:  A releaseShared should be propagated to other
     *               nodes. This is set (for head node only) in
     *               doReleaseShared to ensure propagation
     *               continues, even if other operations have
     *               since intervened.
     *   0:          None of the above
     *
     * The values are arranged numerically to simplify use.
     * Non-negative values mean that a node doesn't need to
     * signal. So, most code doesn't need to check for particular
     * values, just for sign.
     *
     * The field is initialized to 0 for normal sync nodes, and
     * CONDITION for condition nodes.  It is modified using CAS
     * (or when possible, unconditional volatile writes).
     */
    volatile int waitStatus;

    /**
     * Link to predecessor node that current node/thread relies on
     * for checking waitStatus. Assigned during enqueuing, and nulled
     * out (for sake of GC) only upon dequeuing.  Also, upon
     * cancellation of a predecessor, we short-circuit while
     * finding a non-cancelled one, which will always exist
     * because the head node is never cancelled: A node becomes
     * head only as a result of successful acquire. A
     * cancelled thread never succeeds in acquiring, and a thread only
     * cancels itself, not any other node.
     */
    volatile Node prev;

    /**
     * Link to the successor node that the current node/thread
     * unparks upon release. Assigned during enqueuing, adjusted
     * when bypassing cancelled predecessors, and nulled out (for
     * sake of GC) when dequeued.  The enq operation does not
     * assign next field of a predecessor until after attachment,
     * so seeing a null next field does not necessarily mean that
     * node is at end of queue. However, if a next field appears
     * to be null, we can scan prev's from the tail to
     * double-check.  The next field of cancelled nodes is set to
     * point to the node itself instead of null, to make life
     * easier for isOnSyncQueue.
     */
    volatile Node next;

    /**
     * The thread that enqueued this node.  Initialized on
     * construction and nulled out after use.
     */
    volatile Thread thread;

    /**
     * Link to next node waiting on condition, or the special
     * value SHARED.  Because condition queues are accessed only
     * when holding in exclusive mode, we just need a simple
     * linked queue to hold nodes while they are waiting on
     * conditions. They are then transferred to the queue to
     * re-acquire. And because conditions can only be exclusive,
     * we save a field by using special value to indicate shared
     * mode.
     */
    Node nextWaiter;

    /**
     * Returns true if node is waiting in shared mode.
     */
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    /** 返回当前节点的上一个节点，当前节点为该方法的调用对象。 */
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }
    
    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
```



## AQS方法

### acquireQueued

用于处于独占模式且已经处于同步队列中的线程，主要是为了维护节点唤醒功能。

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

### doAcquireShared


> 在共享模式获取锁。获取锁的操作都是需要入同步队列操作的，之后若能获取锁则获取，不能则挂起线程。

```java
private void doAcquireShared(int arg) {
    // 共享模式都是同一个对象Node.SHARED（静态类里面定义的），加入到同步队列。
    final Node node = addWaiter(Node.SHARED); 
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor(); //刚入同步队列节点的前一个节点
            if (p == head) {
                //如果前一个节点是头结点
                int r = tryAcquireShared(arg); //该类由子类实现，判断锁state是否==0
                 //参考： 若 r >= 0 则state == 0, 若 r < 0 则锁state>0。每个子类实现不同
                if (r >= 0) {
                    //到了这里，锁空闲，可以获取
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted) 
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

### addWaiter

> 根据给的模式(独占模式和共享模式) 创建节点并且插入到同步队列尾部(控制了并发）

```java
/** 
 * Creates and enqueues node for current thread and given mode.
 * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
 * @return the new node
 */
private Node addWaiter(Node mode) {
    //mode: 共享模式下是Node.SHARED 独占模式下是Node.EXCLUSIVE即null
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) { //cas设置tail,pred是预期值，node是更新值
            pred.next = node;
            return node;
        }
    }
    //到了这里 队列为空 或者 加入到同步队列并发失败
    enq(node);
    return node;
}
```
### setHeadAndPropagate

> 设置当前node为head，即获取到了锁了。 这个地方有并发吗？有并发但并不影响，相当于设置头结点，

```java
private void setHeadAndPropagate(Node node, int propagate) {
    //node 是获取锁新建的节点，propagate是否可以获取锁 progagate >= 0 可以获取锁
    Node h = head; // Record old head for check below
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
    //propagate什么时候大于0呢 h.waitStatus < 0线程不是取消状态。
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        //到了这里 当前节点是共享模式吗？
        if (s == null || s.isShared()) // node的下一个节点不为空且是共享模式
            doReleaseShared(); //释放共享
    }
}
```
###doReleaseShared

> 释放共享模式的操作

```java
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h); //唤醒一个后继者
            }
            // loop on failed CAS 为什么把head的waitStatus置为了-3 PROPAGATE
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                
        }
        // loop if head changed 什么情况下head会改变呢？
        if (h == head)                   
            break;
    }
}
```
### unparkSuccessor

> 唤醒node的后继者，不是唤醒node。

```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);
    Node s = node.next;
    // 到了这里，当前node的waitStatus有两种 1. 0 2. 1当前节点线程已取消
    if (s == null || s.waitStatus > 0) {
        //当前节点node是最后一个节点 或 其线程已取消等待
        s = null;
        //遍历 去掉已取消等待的节点 
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    //以上：1. 找到node的后继节点中第一个不是取消的节点 2. 把当前node的waitStatus置为0
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

### shouldParkAfterFailedAcquire

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)//-1 需要唤醒后面节点
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
    if (ws > 0) {//1,取消了等待
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {// 0,-2，一般都是0，将前节点设置成需唤醒后节点
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

### parkAndCheckInterrupt

> 挂起线程

```java
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//阻塞当前线程
    return Thread.interrupted(); //返回中断标识，并清除中断标识为false
}
```

### hasQueuedPredecessors

判断同步队列中当前线程是否有前辈节点，若有前辈节点，返回true。若当前线程是头结点（head.next）或者同步队列为空，返回false。

```java
public final boolean hasQueuedPredecessors() {
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

### transferForSignal

转换节点从条件队列到同步队列

```java
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
```

## Condition实现类

```java
public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;
    /** First node of condition queue. */
    private transient Node firstWaiter;
    /** Last node of condition queue. */
    private transient Node lastWaiter;
```


#### unlinkCancelledWaiters

```java
    private void unlinkCancelledWaiters() {
        Node t = firstWaiter;
        Node trail = null;
        while (t != null) {
            Node next = t.nextWaiter;
            if (t.waitStatus != Node.CONDITION) {
                t.nextWaiter = null;
                if (trail == null)
                    firstWaiter = next;
                else
                    trail.nextWaiter = next;
                if (next == null)
                    lastWaiter = trail;
            }
            else
                trail = t;
            t = next;
        }
    }
```
#### signal

```java
    public final void signal() {//唤醒一个Condition节点
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
```
```java
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null); //只唤醒头结点
}
```

#### signalAll

```java
    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignalAll(first);
    }
```
```java
//将Condition队列的所有Condition节点放入到同步节点中并唤醒它们
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);//同步器方法，转换节点从条件队列到同步队列
        first = next;
    } while (first != null);
}	
```

```java
    /**
     * Implements uninterruptible condition wait.
     * <ol>
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * </ol>
     */
    public final void awaitUninterruptibly() {
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if (Thread.interrupted())
                interrupted = true;
        }
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }

    /*
     * For interruptible waits, we need to track whether to throw
     * InterruptedException, if interrupted while blocked on
     * condition, versus reinterrupt current thread, if
     * interrupted while blocked waiting to re-acquire.
     */

    /** Mode meaning to reinterrupt on exit from wait */
    private static final int REINTERRUPT =  1;
    /** Mode meaning to throw InterruptedException on exit from wait */
    private static final int THROW_IE    = -1;

    /**
     * Checks for interrupt, returning THROW_IE if interrupted
     * before signalled, REINTERRUPT if after signalled, or
     * 0 if not interrupted.
     */
    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    }

    /**
     * Throws InterruptedException, reinterrupts current thread, or
     * does nothing, depending on mode.
     */
    private void reportInterruptAfterWait(int interruptMode)
        throws InterruptedException {
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }
```
#### await

```java
    /**
     * Implements interruptible condition wait.
     * <ol>
     * <li> If current thread is interrupted, throw InterruptedException.
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled or interrupted.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * <li> If interrupted while blocked in step 4, throw InterruptedException.
     * </ol>
     */
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
```
#### awaitNanos

```java
    /**
     * Implements timed condition wait.
     * <ol>
     * <li> If current thread is interrupted, throw InterruptedException.
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled, interrupted, or timed out.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * <li> If interrupted while blocked in step 4, throw InterruptedException.
     * </ol>
     */
    public final long awaitNanos(long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    }
```
#### awaitUntil

```
    /**
     * Implements absolute timed condition wait.
     * <ol>
     * <li> If current thread is interrupted, throw InterruptedException.
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled, interrupted, or timed out.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * <li> If interrupted while blocked in step 4, throw InterruptedException.
     * <li> If timed out while blocked in step 4, return false, else true.
     * </ol>
     */
    public final boolean awaitUntil(Date deadline)
            throws InterruptedException {
        long abstime = deadline.getTime();
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (System.currentTimeMillis() > abstime) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            LockSupport.parkUntil(this, abstime);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }
```
#### await

```
    /**
     * Implements timed condition wait.
     * <ol>
     * <li> If current thread is interrupted, throw InterruptedException.
     * <li> Save lock state returned by {@link #getState}.
     * <li> Invoke {@link #release} with saved state as argument,
     *      throwing IllegalMonitorStateException if it fails.
     * <li> Block until signalled, interrupted, or timed out.
     * <li> Reacquire by invoking specialized version of
     *      {@link #acquire} with saved state as argument.
     * <li> If interrupted while blocked in step 4, throw InterruptedException.
     * <li> If timed out while blocked in step 4, return false, else true.
     * </ol>
     */
    public final boolean await(long time, TimeUnit unit)
            throws InterruptedException {
        long nanosTimeout = unit.toNanos(time);
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        final long deadline = System.nanoTime() + nanosTimeout;
        boolean timedout = false;
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            if (nanosTimeout <= 0L) {
                timedout = transferAfterCancelledWait(node);
                break;
            }
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return !timedout;
    }

    //  support for instrumentation

    /**
     * Returns true if this condition was created by the given
     * synchronization object.
     *
     * @return {@code true} if owned
     */
    final boolean isOwnedBy(AbstractQueuedSynchronizer sync) {
        return sync == AbstractQueuedSynchronizer.this;
    }

    /**
     * Queries whether any threads are waiting on this condition.
     * Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.
     *
     * @return {@code true} if there are any waiting threads
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *         returns {@code false}
     */
    protected final boolean hasWaiters() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                return true;
        }
        return false;
    }

    /**
     * Returns an estimate of the number of threads waiting on
     * this condition.
     * Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.
     *
     * @return the estimated number of waiting threads
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *         returns {@code false}
     */
    protected final int getWaitQueueLength() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int n = 0;
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION)
                ++n;
        }
        return n;
    }

    /**
     * Returns a collection containing those threads that may be
     * waiting on this Condition.
     * Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.
     *
     * @return the collection of threads
     * @throws IllegalMonitorStateException if {@link #isHeldExclusively}
     *         returns {@code false}
     */
    protected final Collection<Thread> getWaitingThreads() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        ArrayList<Thread> list = new ArrayList<Thread>();
        for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
            if (w.waitStatus == Node.CONDITION) {
                Thread t = w.thread;
                if (t != null)
                    list.add(t);
            }
        }
        return list;
    }
}
```



### condition应用

> 生产者消费者设计模式实现：两个线程，A线程打印A,B线程打印B,要求打印ABABABABABABABABABAB

```java
public class PrintThread implements Runnable {
    private int COUNT = 10;
    private ReentrantLock reentrantLock;
    private Condition conditionA;
    private Condition conditionB;
    private String c;
    PrintThread(ReentrantLock reentrantLock,Condition conditionA,Condition conditionB,String c){
        this.reentrantLock = reentrantLock;
        this.conditionA = conditionA;
        this.conditionB = conditionB;
        this.c = c;
    }
    @Override
    public void run() {
        try{
            reentrantLock.lock();
            for(int i = 0;i < COUNT; i++){
                System.out.print(c);
                try {
                    conditionB.signal();
                    if(i < COUNT - 1){
                        conditionA.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }finally {
            reentrantLock.unlock();
        }
    }
}

public class ReentranLockTest {
    static ReentrantLock reentrantLock = new ReentrantLock();
    static Condition conditionA = reentrantLock.newCondition();
    static Condition conditionB = reentrantLock.newCondition();
    public static void main(String[] args) {
       PrintThread printThreadA = new PrintThread(reentrantLock,conditionA,conditionB,"A");
       PrintThread printThreadB = new PrintThread(reentrantLock,conditionB,conditionA,"B");
        Thread tA = new Thread(printThreadA);
        Thread tB = new Thread(printThreadB);
        tA.start();
        tB.start();
        //输出BABABABABABABABABABA或者ABABABABABABABABABAB
    }
}
```

#### 例子：ArrayBlockingQueue中使用条件变量Condition

```java
/** Condition for waiting takes */
private final Condition notEmpty;
/** Condition for waiting puts */
private final Condition notFull;
public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
}
```

### Condition是什么

> Condition是对象监视器的替代品，拓展了监视器的语义

* 相同点
  * 都有一组类似的方法
    * 对象监视器:Object.wait()、Object.wait(long timeout)、Object.notify()、Object.notifyAll()
    * Condition对象: Condition.await()、Condition.awaitNanos(long nanosTimeout)、Condition.signal()、Condition.signalAll()
  * 都需要和锁进行关联
    * 对象监视器: 需要进入synchronized语句块（进入对象监视器）才能调用对象监视器的方法
    * Condition对象:需要和一个Lock绑定

- 不同点
  - Condition拓展的语义方法
    - awaitUninterruptibly()：等待时忽略中断
    - awaitUntil(Date deadline) throws InterruptedException：等待到特定日期
  - 使用方法
    - 对象监视器: 进入synchronized语句块（进入对象监视器）后调用Object.wait()
    - Condition对象: 需要和一个Lock绑定，并显示的调用lock()获取锁，然后调用 Condition.await()
  - 等待队列数量
    - 对象监视器: 1个
    - Condition对象: 多个。通过多次调用lock.newCondition()返回多个等待队列

### await()

Condition内部定义类的方法，该方法把当前线程作为参数新建一个节点放入条件队列中(不是同步队列)，释放可重入锁状态，同时挂起当前线程。

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node); //释放锁状态
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

### 扩展：

多个Condition

state 0 

### 源码：LockSupport

> LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。
>
> parkBlockerOffset：parkBlocker用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。parkBlocke在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。

```java
// Hotspot implementation via intrinsics API
private static final sun.misc.Unsafe UNSAFE;
private static final long parkBlockerOffset;
static {
    try {
        UNSAFE = sun.misc.Unsafe.getUnsafe();
        Class<?> tk = Thread.class;
        parkBlockerOffset = UNSAFE.objectFieldOffset
            (tk.getDeclaredField("parkBlocker"));
    } catch (Exception ex) { throw new Error(ex); }
}
```



> JUC(Java Util Concurrency)仅用简单的park, unpark和CAS指令就实现了各种高级同步数据结构

#### Unsafe.park和Unsafe.unpark

> 其实park/unpark的设计原理核心是“许可”：park是等待一个许可，unpark是为某线程提供一个许可。
>
> 在Linux系统下是用的Posix线程库pthread中的mutex（互斥量），condition（条件变量）来实现的。mutex和condition保护了一个_counter的变量，当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。

- **park 过程**
  * 当调用park时，先尝试能否直接拿到“许可”，即_counter>0时
    * 如果成功，则把\_counter设置为0，并返回
    * 如果不成功，则构造一个ThreadBlockInVM，然后检查\_counter是不是>0，如果是，则把\_counter设置为0，unlock mutex并返回；否则，再判断等待的时间，然后再调用pthread_cond_wait函数等待，如果等待返回，则把 \_counter设置为0，unlock mutex并返回

* **unpark 过程**
  * 当unpark时，直接设置\_counter为1，再unlock mutex返回
    * 如果\_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程：



### 如何终止一个Java线程

对于runnable的线程，利用一个变量做标记位，定期检查

对于非runnable的线程，应该采取中断的方式退出阻塞，并处理捕获的中断异常

- 对于大部分阻塞线程的方法，使用Thread.interrupt()，可以立刻退出等待，抛出InterruptedException
    这些方法包括Object.wait(), Thread.join()，Thread.sleep()，以及各种AQS衍生类：
  - Lock.lockInterruptibly()**等任何显示声明throws InterruptedException的方法**。
  - 被阻塞的nio Channel也会响应interrupt()，抛出ClosedByInterruptException，相应nio通道需要实现java.nio.channels.InterruptibleChannel接口
  - 还有一些阻塞方法不会响应interrupt，如等待进入synchronized段、Lock.lock()。他们不能被动的退出阻塞状态。

## 趣题实践

1. 循环打印ABABAB...十次

```java
public class ReentranLockTest {
    static ReentrantLock reentrantLock = new ReentrantLock();
    static Condition conditionA = reentrantLock.newCondition();
    static Condition conditionB = reentrantLock.newCondition();
    static CountDownLatch latch = new CountDownLatch(1);

    public static void main(String[] args) {
        PrintThread printThreadA = new PrintThread(reentrantLock, conditionA, conditionB, "A", latch);
        PrintThread printThreadB = new PrintThread(reentrantLock, conditionB, conditionA, "B", latch);
        Thread tA = new Thread(printThreadA);
        Thread tB = new Thread(printThreadB);

        tB.start();
        try {
            Thread.sleep(100L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        tA.start();
    }
}
```



```java
public class PrintThread implements Runnable {
    private int COUNT = 10;
    private ReentrantLock reentrantLock;
    private Condition conditionA;
    private Condition conditionB;
    private CountDownLatch latch;
    private String c;

    PrintThread(ReentrantLock reentrantLock, Condition conditionA, Condition conditionB, String c, CountDownLatch latch) {
        this.reentrantLock = reentrantLock;
        this.conditionA = conditionA;
        this.conditionB = conditionB;
        this.c = c;
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            if (c.equals("A")) {
                //保证A先加锁
                reentrantLock.lock();
                latch.countDown();
            } else {
                latch.await();
                reentrantLock.lock();//这里会等待conditionA.await()执行才能继续
            }

            for (int i = 0; i < COUNT; i++) {
                System.out.print(c);
                try {
                    conditionB.signal(); //将一个Condition节点放入等待队列，等待执行
                    if (i < COUNT - 1) {
                        conditionA.await(); //此处是关键，会将锁state清空
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            reentrantLock.unlock();
        }
    }
}
```

#### 三线程循环打印ABC十次？




# CountDownLatch

> CountDownLathch使用场景：比如主线程启动子线程之后，需等待子线程都执行完，那么就需在主线程调用await()，每个子线程执行完成任务之后执行countDown()，待锁state减到0的子线程会唤醒主线程。如此便实现了主线程与子线程的协作工作。当然不一定主线程等待，任何线程都可以作为等待线程。而countDown()的线程并没被阻塞，countDown()底层实现是sync.releaseShared(1)。
>
> **存在多个线程调用CountDownLatch.await()的场景**

## 示例

> 一个线程A等待多线程执行完成的同步，等待指定数量的线程运行了countDownLatch.countDown()把state减到0 ，则挂起的A线程才能进入就绪状态，继续执行。因为执行await()线程要等待锁state减到0，并不一定是等待执行countDown()的线程执行完，只需state减到0的线程唤醒所有线程，除非当前线程发生中断。

```java
public static void main(String[] args) {
    CountDownLatch countDownLatch = new CountDownLatch(6);
    ExecutorService pool = Executors.newCachedThreadPool();
    for (int i = 0; i < 5; i++) {
        pool.submit(new CountDownLatchTest(countDownLatch, String.valueOf(i)));
    }
    try {
        countDownLatch.await(); // 1.若latch count 为0 则 继续执行；2.若不为0 则挂起当前线程；3.某个减少latch count到0的线程唤醒它。
        System.out.println("await()线程,任务汇总之后...");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        pool.shutdown();
    }
}

static class CountDownLatchTest implements Runnable {
    CountDownLatch countDownLatch;
    String i;
    CountDownLatchTest(CountDownLatch countDownLatch, String i) {
        this.countDownLatch = countDownLatch;
        this.i = i;
    }
    @Override
    public void run() {
        System.out.println("hello->" + i);
        countDownLatch.countDown();
        System.out.println("sleep 3000ms");
    }
}
```



## 源码分析

1. CountDownLatch有什么特性，使用的场景有哪些？

   > 可以在一个线程中等待其他线程，然后其他线程中把state减到0的线程唤醒等待的线程。即在各自任务中的某个点停住，等待所有线程都就位之后，由最后一个到位的线程唤醒其他线程。

2. CountDownLatch的方法？

   > * countDown()
   >
   > * await()

3. 怎么实现主控线程（调用await()的线程）等待其他线程（调用countDown()方法的线程）的？

   > new CountDownLatch(n)传入了n，当n减到0的线程唤醒被await()的线程。传入的n是AQS同步器的锁变量state，当state减到0时，唤醒主线程（调用await()方法挂起的线程）。由减到0的线程唤醒被await()阻塞的线程。


### await()方法

> CountDownLatch.await()调用的是共享模式的可中断获取锁，存在多个线程调用CountDownLatch.await()的场景

```java
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```

> 调用AQS同步器中的代码

```java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0) //子类实现了该方法
        // 若锁state大于0
        doAcquireSharedInterruptibly(arg);
}
```

> 若锁state大于0，则进入if内部，执行doAcquireSharedInterruptibly(arg)方法

```java
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
```

> 若锁state大于0，则调用父类AQS同步器中的doAcquireSharedInterruptibly代码，该代码实现了什么呢？

```java
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    //到了这里 state锁 大于0
    final Node node = addWaiter(Node.SHARED); //新建一个当前线程的Node，添加到同步器队列的尾部
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor(); //取上一个节点
            if (p == head) { //上一个节点是头结点，自身节点是队列的第一个元素，头结点不属于队列
                int r = tryAcquireShared(arg); //获取锁state状态
                if (r >= 0) { //r == 1 锁state变成了0，可以获取锁了
            //设置头结点，并将头节点的waitStatus设置成PROPAGATE(-3)
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            // 到了这里，则不是头节点，将上一个节点设置成SIGNAL 同时挂起线程
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

### countDown()方法

> 释放共享模式的锁

```java
public void countDown() {
    sync.releaseShared(1);
}
```

> 调用父类AQS同步器中的代码

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        //若锁state刚好减到0，这进入到了这里
        doReleaseShared();
        return true;
    }
    return false;
}
```

> CountDownLatch自身实现的tryReleaseShared方法，如果锁state减为0了，直接返回false。如果锁state不为0，则减一，同时返回 state == 0 的判断。

```java
protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc)) //多线程并发这里失败了会产生问题吗？
            return nextc == 0;
    }
}
```

> 调用了父类AQS同步器的方法，在锁state减为0时调用了如下的方法，唤醒被CountDownLatch.await()阻塞的线程。

```java
private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h); //唤醒后继者
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```



## CountDownLatch 和 thread.join()方法的区别

* CountDownLatch
  * 在子线程未完成之前，主线程会一直处于挂起状态。（LockSupport.park())
  * 子线程的控制方法不同。CountDownLatch中，多个子线程的控制，让各自子线程去定义任务结束的条件，即调用countDown()的时机，这个时候子线程不一定结束了。thread.join()是必须等待子线程执行完成，在主线程中调用thread.join()来实现的。
* thread.join()
  * 每个子线程都需要调用一遍thread.join()。（join需要线程实例来调用)，能多个子线程join()吗？ 可以的，thread.isAlive()来判断当前线程是否挂起（obj.wait(0)直接挂起等待唤醒），若后面的thread.join()方法的thread已经结束，调用join方法会直接返回（因为isAlive)
  * 若开启了多个子线程，然后调用了在主线程里使用子线程实例调用了join方法，主线程是按照调用join方法的顺序一个线程一个线程地等待子线程执行完成。前面join的子线程没执行完，主线程会一直等待。(在没传入参数的情况下)
  * thread.join()方法的缺点：子线程未完成之前，主线程会一直运行就绪挂起，运行就绪挂起三种状态之间流转？，比较耗费资源。

### thread.join()示例

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(()->{
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("join thread");
    });
    thread.start();
    thread.join();
    System.out.println("main thread");
}
```

> 结果

```
join thread
main thread
```



## CountDownLatch（闭锁） 和 CyclicBarrier（栅栏）的区别

* CountDownLatch（闭锁）是一个（多个）线程等待其他多个线程执行完指定代码之后才能被唤醒。被阻塞的的线程只有一个（即等待其他线程执行完的线程），**其他执行任务的线程不会阻塞（即调用.countDown()的线程），调用.countDown()的线程进行state--，state==0时唤醒.await的线程**。 怎么感觉像join呢？

* CyclicBarrier（栅栏）是多个线程到达了各自线程内部的指定的点（调用await()的代码行），然后挂起，指定数量的线程中最后一个到达的线程会启动回调线程，然后唤醒之前挂起的所有线程，利用了ReentrantLock的.newCondition()，条件队列（链表，头指针，尾指针）。


# CyclicBarrier

## 问题

1. CyclicBarrier有哪些方法？
2. CyclicBarrier怎么实现多线停住？ 在停住所有线程到位之后并发执行的？
3. 栅栏怎么实现多次重复使用的？ 有使用场景吗？

## 示例

```java
public static void main(String[] args) {
    int NUM = 3;
    ExecutorService executorService = Executors.newCachedThreadPool();
    
    CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM, ()->{
        System.out.println("各个线程都执行完成，本线程汇总一下...");
    });
    for (int i = 0; i < NUM; i++) {
        executorService.submit(new CylicBarrierTest(String.valueOf(i), cyclicBarrier));
    }
    executorService.shutdown();
}
static class CylicBarrierTest implements Runnable {
    private String i;
    private CyclicBarrier cyclicBarrier;
    CylicBarrierTest(String i, CyclicBarrier cyclicBarrier) {
        this.i = i;
        this.cyclicBarrier = cyclicBarrier;
    }
    @Override
    public void run() {
        System.out.println("hello" + i);
        try {
            cyclicBarrier.await(); //多线程在这里停止
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
        System.out.println(i + ": await之后");
    }
}
```

> 输出结果

```
hello2
hello1
hello0
各个线程都执行完成，本线程汇总一下... //回调线程执行的结果
0: await之后 
1: await之后
2: await之后
```



## 源码分析

### CyclicBarrier

```java
public class CyclicBarrier {
    /**
     * Each use of the barrier is represented as a generation instance.
     * The generation changes whenever the barrier is tripped, or
     * is reset. There can be many generations associated with threads
     * using the barrier - due to the non-deterministic way the lock
     * may be allocated to waiting threads - but only one of these
     * can be active at a time (the one to which {@code count} applies)
     * and all the rest are either broken or tripped.
     * There need not be an active generation if there has been a break
     * but no subsequent reset.
     */
    private static class Generation {
        boolean broken = false;
    }

    /** The lock for guarding barrier entry */
    private final ReentrantLock lock = new ReentrantLock();
    /** Condition to wait on until tripped */
    private final Condition trip = lock.newCondition();
    /** The number of parties */
    private final int parties;
    /* The command to run when tripped */
    private final Runnable barrierCommand;
    /** The current generation */
    private Generation generation = new Generation();

    /**
     * Number of parties still waiting. Counts down from parties to 0
     * on each generation.  It is reset to parties on each new
     * generation or when broken.
     */
    private int count;

    /**
     * Updates state on barrier trip and wakes up everyone.
     * Called only while holding lock.
     */
    private void nextGeneration() {
        // signal completion of last generation
        trip.signalAll();
        // set up next generation
        count = parties;
        generation = new Generation();
    }

    /**
     * Sets current barrier generation as broken and wakes up everyone.
     * Called only while holding lock.
     */
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        trip.signalAll();
    }
}
```

### 内部方法

#### await

> 多线程在栅栏停住，指定数量线程到位之后同时被唤醒

```java
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
```

#### dowait

> 调用了dowait()

```java
private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;

        if (g.broken)
            throw new BrokenBarrierException();

        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }

        int index = --count;//此处需同步
        if (index == 0) {  // tripped，栅栏倾倒
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();//执行所有线程到达之后的任务
                ranAction = true;
                nextGeneration();//status值减到0时，进入下一代，status又变为初始值parties，把条件队列的节点加入到同步队列（是线程安全的，外面加了重入锁），该线程unlock后会唤醒前面加到同步队列的线程。
                return 0;
            } finally {
                if (!ranAction)
                    breakBarrier();
            }
        }

        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)
                    trip.await(); //关键：加入到条件队列，等到栅栏倾倒时把条件队列的节点加入到同步队列
                else if (nanos > 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation && ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    // We're about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // "belong" to subsequent execution.
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();

            if (g != generation)
                return index;

            if (timed && nanos <= 0L) {//在定时等待情况下
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
```



### 内部类

```java
/**
 * Each use of the barrier is represented as a generation instance.
 * The generation changes whenever the barrier is tripped, or
 * is reset. There can be many generations associated with threads
 * using the barrier - due to the non-deterministic way the lock
 * may be allocated to waiting threads - but only one of these
 * can be active at a time (the one to which {@code count} applies)
 * and all the rest are either broken or tripped.
 * There need not be an active generation if there has been a break
 * but no subsequent reset.
 */
private static class Generation {
    boolean broken = false;
}
```



layout:     post
title:	JUC专题
subtitle: 	ReentrantLock
date:       2019-12-24
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# ReentrantLock

### 问题

#### ReentrantLock是什么？

ReentrantLock是可重入、非公平和公平锁的显式实现，可以实现多条件的等待（即多个锁）。

#### ReentrantLock有什么用？使用场景有哪些？

#### ReentrantLock有哪些特性？怎么实现的这些特性？




### 源码：ReentrantLock

> ReentrantLock重入锁，内部类继承AbstractQueueSynchronizer，实现Lock接口。具有重入性，同一线程能够重复获取进入锁。
>
> 在java关键字synchronized隐式支持重入性（synchronized通过获取自增，释放自减的方式实现重入）。
>
> ReentrantLock支持公平锁和非公平锁两种方式。

#### ReentrantLock重入性

以非公平锁为例，重入锁加锁

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {//重入锁实现点。同一线程再次进入
        int nextc = c + acquires;//state + 1
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);//更新state，The synchronization state.
        return true;
    }
    return false;
}
```

以非公平锁为例，重入锁释放

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;//state - 1
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

最大重入次数：Integer.MAX_VALUE，超过了会抛出异常

Exception in thread "main" java.lang.Error: Maximum lock count exceeded
	at java.util.concurrent.locks.ReentrantLock\$Sync.nonfairTryAcquire(ReentrantLock.java:141)
	at java.util.concurrent.locks.ReentrantLock\$NonfairSync.tryAcquire(ReentrantLock.java:213)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1198)
	at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)
	at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)
	at com.github.chuangkel.java_learn.base.thread.threadMutual.ReentrantLockTest.main(ReentrantLockTest.java:18)

#### ReentrantLock公平锁和非公平锁

公平和非公平锁的实现区别只有加锁过程不同： 

1. 公平锁的加锁过程，根据实现同步器的子类公平锁的tryAquire方法判断，**先判断state是为0并且同步队列没有后继者**，若满足进行state的CAS修改，CAS修改成功则获取到锁，设置当前线程为持有锁的线程。若该线程是重入，则state加一，成功获取到锁。若不满足或CAS修改state失败则新建一个节点放入同步队列中。 获取同步队列中新加入节点的上一个节点，如果上一个节点是head节点，同时尝试获取修改state状态，CAS修改state成功获取到锁。 如果不是头结点或者CAS修改state失败，往前遍历同步队列，淘汰已经取消等待的节点，保证上一个节点的waitStatus状态是SIGNAL，再park当前线程。保证了上一个节点释放锁时会唤醒当前节点线程。
2.  非公平锁加锁过程，根据同步器子类非公平锁实现的方法tryAquire，**不会判断state是否为0，不会判断同步队列是否有等待节点**，直接CAS修改state，修改成功或者当前线程是可重入的，那么成功获取到锁，把当前线程设置到头节点变量中。失败则加入同步队列，加入到同步队列都是同步器框架实现的，所以非公平锁和公平锁加入同步队列的过程相同。

**区别：** 公平锁可以插队，非公平锁不可以插队

ReentrantLock支持两种锁：公平锁和非公平锁。

```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

tryAcquire(arg)方法在同步器中预留给子类实现。

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

##### 公平锁

公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，满足FIFO，会产生频繁的上下文切换。

公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换

```java
final void lock() {
    acquire(1);
}
```

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {//公平锁多了hasQueuedPredecessors(),判断当前线程是否有前驱节点
        if (!hasQueuedPredecessors() && //根据公平性，有前驱节点将获取锁失败
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

##### 非公平锁

非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。而非公平锁会降低一定的上下文切换，降低性能开销。因此，**ReentrantLock默认选择的是非公平锁**，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。

ReentrantLock默认非公平锁  java.util.concurrent.locks.ReentrantLock#ReentrantLock()

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

NonfairSync 一上来就干，直接CAS

```java
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

上面的失败了再按公平锁的套路来，注意还是没有判断同步队列

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) { //没有鸟同步队列
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```



lockInterruptly调用了该方法，在尝试获取锁之前如果线程发生了中断，则抛出InterruptedException

```java
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
```



### ReentrantLock和Synchronized的区别？

| 区别                     | ReentrantLock                                                | Synchronized                                                 |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现                     | 基于Unsafe类的实现来挂起和唤醒线程，采用双向链表的方式存储等待的线程节点 | jvm层面的实现,通过对象头来记录偏向锁、轻量级锁、重量级锁的标识，每个锁有对应的监视器对象，用来控制线程的切换 |
| 公平性和非公平锁         | 可以实现公平锁和非公平锁                                     | 只能使用公平锁                                               |
| 锁升级、锁粗化、锁消除、 | 无                                                           | jvm实现会对锁进行锁升级，通过对象头锁标识，来进行锁的升级，自动进行锁的粗化比如在for循环类加锁和锁的消除，对不可能存在锁竞争的地方进行锁的消除，比如字符串相加。 |
|                          |                                                              |                                                              |

ReentrantLock可中断锁是怎么实现的？Synchronized可以中断吗?

```java
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
```

需要在acquireInterruptibly方法调用之前中断该线程。





# ReentrantReadWriteLock
> 读写锁都是同一把锁，都是父类AQS同步器的锁state

问题

1. 读锁怎么实现共享的？即不互斥的？
2. 写锁到读锁是怎么降价的 
3. 



## 代码

### Sync 内部类

```java
/** 同步器的读写锁实现，子类是公平和非公平锁 */
abstract static class Sync extends AbstractQueuedSynchronizer {
    /*锁状态state分成两个无符号短整型，低位代表独占模式写锁的持有数量，高位代表共享锁读锁的持有数量 */
    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

    /** 返回持有共享锁线程的数量  */
    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
    /** Returns the number of exclusive holds represented in count  */
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

    /**
     * A counter for per-thread read hold counts.
     * Maintained as a ThreadLocal; cached in cachedHoldCounter
     */
    static final class HoldCounter {
        int count = 0;
        // Use id, not reference, to avoid garbage retention
        final long tid = getThreadId(Thread.currentThread());
    }

    /**
     * ThreadLocal subclass. Easiest to explicitly define for sake
     * of deserialization mechanics.
     */
    static final class ThreadLocalHoldCounter
        extends ThreadLocal<HoldCounter> {
        public HoldCounter initialValue() {
            return new HoldCounter();
        }
    }

    /**
     * The number of reentrant read locks held by current thread.
     * Initialized only in constructor and readObject.
     * Removed whenever a thread's read hold count drops to 0.
     */
    private transient ThreadLocalHoldCounter readHolds;

    /**
     * The hold count of the last thread to successfully acquire
     * readLock. This saves ThreadLocal lookup in the common case
     * where the next thread to release is the last one to
     * acquire. This is non-volatile since it is just used
     * as a heuristic, and would be great for threads to cache.
     *
     * <p>Can outlive the Thread for which it is caching the read
     * hold count, but avoids garbage retention by not retaining a
     * reference to the Thread.
     *
     * <p>Accessed via a benign data race; relies on the memory
     * model's final field and out-of-thin-air guarantees.
     */
    private transient HoldCounter cachedHoldCounter;

    /*
     * firstReader是第一个获取读锁的线程，firstReaderHoldCount是firstReader的持有count。更精确地说，firstReader是唯一的成功并发修改改变共享count从0到1的线程*/
    private transient Thread firstReader = null;
    //第一个线程的重入数量
    private transient int firstReaderHoldCount;

    Sync() {
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    }

    /*
     * Acquires and releases use the same code for fair and
     * nonfair locks, but differ in whether/how they allow barging
     * when queues are non-empty.
     */

    /**
     * Returns true if the current thread, when trying to acquire
     * the read lock, and otherwise eligible to do so, should block
     * because of policy for overtaking other waiting threads.
     */
    abstract boolean readerShouldBlock();

    /**
     * Returns true if the current thread, when trying to acquire
     * the write lock, and otherwise eligible to do so, should block
     * because of policy for overtaking other waiting threads.
     */
    abstract boolean writerShouldBlock();

    /*
     * Note that tryRelease and tryAcquire can be called by
     * Conditions. So it is possible that their arguments contain
     * both read and write holds that are all released during a
     * condition wait and re-established in tryAcquire.
     */
}

```

#### tryRelease

```java
protected final boolean tryRelease(int releases) {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    int nextc = getState() - releases;
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    setState(nextc);
    return free;
}
```

#### tryAcquire

```java
protected final boolean tryAcquire(int acquires) {
    /*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```

#### tryAcquireShared

```java
protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    if (firstReader == current) {
        // assert firstReaderHoldCount > 0;
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    } else {
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count <= 1) {
            readHolds.remove();
            if (count <= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            // Releasing the read lock has no effect on readers,
            // but it may allow waiting writers to proceed if
            // both read and write locks are now free.
            return nextc == 0;
    }
}
private IllegalMonitorStateException unmatchedUnlockException() {
    return new IllegalMonitorStateException(
        "attempt to unlock read lock, not locked by current thread");
}
```

#### tryAcquireShared

```java
protected final int tryAcquireShared(int unused) {
    /*
     * Walkthrough:
     * 1. If write lock held by another thread, fail.
     * 2. Otherwise, this thread is eligible for
     *    lock wrt state, so ask if it should block
     *    because of queue policy. If not, try
     *    to grant by CASing state and updating count.
     *    Note that step does not check for reentrant
     *    acquires, which is postponed to full version
     *    to avoid having to check hold count in
     *    the more typical non-reentrant case.
     * 3. If step 2 fails either because thread
     *    apparently not eligible or CAS fails or count
     *    saturated, chain to version with full retry loop.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
    /*当前锁状态state没有写锁，readerShouldBlock方法如有同步队列有前节点，返回true,没有同步节点或队列为空，返回false*/
    if (!readerShouldBlock() && //头结点了
        r < MAX_COUNT &&
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    //不是头结点
    return fullTryAcquireShared(current);
}
```

#### fullTryAcquireShared

```java
/** 获取读锁的完整版，处理CAS失败，上面的tryAcquireShared没有处理可重入读 */
final int fullTryAcquireShared(Thread current) {
    /*
     * This code is in part redundant with that in
     * tryAcquireShared but is simpler overall by not
     * complicating tryAcquireShared with interactions between
     * retries and lazily reading hold counts.
     */
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;
            // else we hold the exclusive lock; blocking here
            // would cause deadlock.
        } else if (readerShouldBlock()) {
            // Make sure we're not acquiring read lock reentrantly
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
            } else {
                if (rh == null) {
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) {
                        rh = readHolds.get();
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                if (rh.count == 0)
                    return -1;
            }
        }
        if (sharedCount(c) == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1;
        }
    }
}
```

#### tryWriteLock

```java
/**
 * Performs tryLock for write, enabling barging in both modes.
 * This is identical in effect to tryAcquire except for lack
 * of calls to writerShouldBlock.
 */
final boolean tryWriteLock() {
    Thread current = Thread.currentThread();
    int c = getState();
    if (c != 0) {
        int w = exclusiveCount(c);
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
    }
    if (!compareAndSetState(c, c + 1))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```

#### tryReadLock

```java
/**
 * Performs tryLock for read, enabling barging in both modes.
 * This is identical in effect to tryAcquireShared except for
 * lack of calls to readerShouldBlock.
 */
final boolean tryReadLock() {
    Thread current = Thread.currentThread();
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current)
            return false;
        int r = sharedCount(c);
        if (r == MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }
            return true;
        }
    }
}

protected final boolean isHeldExclusively() {
    // While we must in general read state before owner,
    // we don't need to do so to check if current thread is owner
    return getExclusiveOwnerThread() == Thread.currentThread();
}

// Methods relayed to outer class

final ConditionObject newCondition() {
    return new ConditionObject();
}

final Thread getOwner() {
    // Must read state before owner to ensure memory consistency
    return ((exclusiveCount(getState()) == 0) ?
            null :
            getExclusiveOwnerThread());
}

final int getReadLockCount() {
    return sharedCount(getState());
}

final boolean isWriteLocked() {
    return exclusiveCount(getState()) != 0;
}

final int getWriteHoldCount() {
    return isHeldExclusively() ? exclusiveCount(getState()) : 0;
}

final int getReadHoldCount() {
    if (getReadLockCount() == 0)
        return 0;

    Thread current = Thread.currentThread();
    if (firstReader == current)
        return firstReaderHoldCount;

    HoldCounter rh = cachedHoldCounter;
    if (rh != null && rh.tid == getThreadId(current))
        return rh.count;

    int count = readHolds.get().count;
    if (count == 0) readHolds.remove();
    return count;
}

/**
 * Reconstitutes the instance from a stream (that is, deserializes it).
 */
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    readHolds = new ThreadLocalHoldCounter();
    setState(0); // reset to unlocked state
}

final int getCount() { return getState(); }
```


### 方法



## 关系



### 实例： 读锁和读锁之间的关系

```java
public static void main(String[] args) {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,1000L,
            TimeUnit.MILLISECONDS,new LinkedBlockingDeque<>(),new PersonThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());

    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
    //读锁和读锁之间的关系
    for(int i = 0; i < 2; i++){
        executor.submit(()->{
            readAndRead(rwLock,cyclicBarrier);
        });
    }
}
public static void readAndRead(ReentrantReadWriteLock rwLock, CyclicBarrier cyclicBarrier){
    rwLock.readLock().lock();
    try {
        cyclicBarrier.await();
        for(int i = 0; i < 20; i++){
            Thread.sleep(200L);//挂起线程，让实验更直观
            System.out.println("threadGroupName: " + Thread.currentThread().getThreadGroup().getName()+
                    ", threadName: "+Thread.currentThread().getName());
        }
    }catch (Exception e){
    }finally {
        rwLock.readLock().unlock();
    }
}
static class PersonThreadFactory implements ThreadFactory{
    ThreadGroup group = new ThreadGroup("person");
    private final AtomicInteger atomic = new AtomicInteger(1);
    private final String prefix = "pthread-";
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(group,r,prefix + atomic.getAndIncrement());
    }
}
```

> 读锁之间是共享的，由下可以看出是交替执行的，多个读线程之间共享了锁，执行了同一段代码块。

```
threadGroupName: person, threadName: pthread-1
threadGroupName: person, threadName: pthread-2
threadGroupName: person, threadName: pthread-2
threadGroupName: person, threadName: pthread-1
threadGroupName: person, threadName: pthread-1
threadGroupName: person, threadName: pthread-2
//...
```



### 实例：读锁和写锁的关系

```java
public static void main(String[] args) {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,1000L,
            TimeUnit.MILLISECONDS,new LinkedBlockingDeque<>(),new PersonThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());

    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
    //读锁和写锁之间的关系
    executor.submit(()->{
        readAction(rwLock,cyclicBarrier);
    });
    executor.submit(()->{
        writeAction(rwLock,cyclicBarrier);
    });
}
public static void readAction(ReentrantReadWriteLock rwLock, CyclicBarrier cyclicBarrier){
    rwLock.readLock().lock();
    try {
        //cyclicBarrier.await();
        for(int i = 0; i < 20; i++){
            Thread.sleep(100L);
            System.out.println("threadGroupName: " + Thread.currentThread().getThreadGroup().getName()+
                    ", threadName: "+Thread.currentThread().getName()+", 正在读...");
        }
    }catch (Exception e){
    }finally {
        rwLock.readLock().unlock();
    }
}
public static void writeAction(ReentrantReadWriteLock rwLock, CyclicBarrier cyclicBarrier){
    rwLock.writeLock().lock();
    try {
        // 这个同步需去掉，若获得锁到了这里，又将当下线程挂起，挂起不会释放锁？，造成死锁。
        //cyclicBarrier.await(); 
        for(int i = 0; i < 20; i++){
            Thread.sleep(100L);
            System.out.println("threadGroupName: " + Thread.currentThread().getThreadGroup().getName()+
                    ", threadName: "+Thread.currentThread().getName()+", 正在写...");
        }
    }catch (Exception e){
    }finally {
        rwLock.writeLock().unlock();
    }
}
```

> 读锁和写锁互斥，是怎么实现的？

```
//...
threadGroupName: person, threadName: pthread-1, 正在读...
threadGroupName: person, threadName: pthread-1, 正在读...
threadGroupName: person, threadName: pthread-2, 正在写...
threadGroupName: person, threadName: pthread-2, 正在写...
//...
```



### 实例：写锁和写锁之间的关系

> 写锁和写锁之间排斥

```java
public static void main(String[] args) {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,1000L,
            TimeUnit.MILLISECONDS,new LinkedBlockingDeque<>(),new PersonThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());

    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);
    //写锁和写锁之间的关系
    for(int i = 0; i < 2; i++){
        executor.submit(()->{
            writeAndWrite(rwLock,cyclicBarrier);
        });
    }
}
public static void writeAndWrite(ReentrantReadWriteLock rwLock, CyclicBarrier cyclicBarrier){
    rwLock.writeLock().lock();
    try {
        //cyclicBarrier.await();
        for(int i = 0; i < 20; i++){
            Thread.sleep(200L);
            System.out.println("threadGroupName: " + Thread.currentThread().getThreadGroup().getName()+
                    ", threadName: "+Thread.currentThread().getName());
        }
    }catch (Exception e){
    }finally {
        rwLock.writeLock().unlock();
    }
}
```

> 输出结果如下：

```java
//...
threadGroupName: person, threadName: pthread-1
threadGroupName: person, threadName: pthread-1
threadGroupName: person, threadName: pthread-2
threadGroupName: person, threadName: pthread-2
//...
```

## 读写锁的实践

> 读阻塞写，不阻塞其他读
>
> 写阻塞读，又阻塞其他写





# Synchronized-锁优化

## 锁消除

**引言**

1. 什么是锁消除？
2. 为什么要锁消除？
3. 有哪些锁消除的案例

**分析**

1. 什么是锁消除？为什么要锁消除？

   因为加锁和释放锁都是具有成本的。锁消除顾名思义消除锁，对理论上不存在并发的加锁代码的锁进行锁消除，从而避免一定的系统开销。在堆上的数据如果不可能被其他线程访问到，那么则可以当做栈上的数据使用，认为它是线程私有的，自然就无需加锁。

2. 锁是怎么消除的


       编译器基于逃逸分析技术进行了锁的消除。需开启系统参数：

  ```
  -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks
  // +DoEscapeAnalysis 表示开启逃逸分析技术 +EliminateLocks表示锁消除
  ```

3. 逃逸分析技术是什么呢

  逃逸分析技术是目前比较前沿的java虚拟机的优化分析技术，它与类继承关系分析不一样，并不直接优化代码手段，而是为其他优化手段提供依据的分析技术。

  逃逸分析的行为就是分析对象动态作用域：当一个对象定义在方法内部，并且作为方法调用返回参数，那么该对象可能被其他方法使用，则称改对象方法逃逸了。当一个对象赋值给静态变量或者可以在其他线程中访问到的变量，那么该对象可能会被其他线程访问，则称为线程逃逸。

  如果能证明一个对象不会方法逃逸或者线程逃逸，那么可以对该变量做一些优化，比如：

  栈上分配：为什么要有栈上分配？ 栈的回收时会回收

  标量替换：标量指无法拆分成更小的数据类型，比如byte,boolean,short(2字节),char(2字节),int,float,long,double。聚合量指可以继续分解的数据，比如对象。如果一个对象不会被外部访问并且该对象可以分解的话，那程序执行的时候可能不创建这个对象，而是直接创建被这个方法用到的若干个成员变量来代替，优化之后直接在栈上分配和读写该对象的成员变量。

  同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析技术能确定一个变量不会逃逸出当前线程被其他线程访问到，即该变量的读写不存在竞争，则可以消除相应的同步措施。

  是否逃出变量的作用域，比如下面的方法中的sb对象，若将该对象返回，则编译器会将其作为全局变量使用，就有可能存在线程安全的问题，就可以锁sb对象发生逃逸了，因而append方法上的锁就不可以消除。

4. 有哪些锁消除的案例

   ```mysql
   public class StringContract {
       /**
        * 每一个sb.append都是一个同步方法。sb变量处于方法内部，每一个方法调用都会开辟一个新的对象，
        * 所以sb.append的锁可以消除
        * 注意：若sb作为返回值返回，那sb就是一个全局对象，从而存在并发问题。
        */
       private static String contract(String a,String b,String c){
           StringBuffer sb = new StringBuffer();
           sb.append(a);
           sb.append(b);
           sb.append(c);
           return sb.toString();
       }
   }
   ```

   

## 锁粗化

**引言**

1. 什么是锁粗化？为什么要锁粗化
2. 锁粗化实例

**分析**
1. 什么是锁粗化？为什么要锁粗化

   平时写代码推荐的写法是将同步块的作用范围要尽量小，这样做事为了执行同步块的时间尽可能少，若存在锁竞争，其他等待的线程也能尽快拿到锁。大部分情况下，以上原则没什么问题，但若出现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁是出现在循环体中。比如上面的sp.append()方法（append方法实现加了关键字synchronized）,在第一个sb.append前面加锁，锁直到最后一个sb.append()方法结束。 循环体里面出现了加锁解锁，则把锁加到for循环上，这样就避免了反复的加锁和解锁带来的性能开销。 这些优化都是java虚拟机自动做的。

2. 锁粗化实例



## 偏向锁

对象头信息包含两部分，第一部分为Mark Word，其结构如下表。为了节省空间，java虚拟机根据锁标志位的不同存储不同的数据。

![1571039443563](/..\img\1571039443563.png)

偏向锁时锁标志位为01

## 轻量级锁

轻量级锁时，锁标志为00，拷贝Mark Word到线程的栈中为Displaced Mark Word，再通过CAS操作将对象头的Mark Word更新成指向Displaced Mark Word的指针。



## 自旋锁和适应性自旋

适应性自旋是jvm通过之前的轻量级锁的占用的时间来动态调节后来线程的自旋时间。



### 例子：

```java
public class VolatileB {
    public static void main(String[] args) {
        Object object = new Object();
        Thread threadA = new Thread(() -> {
            int i = 0;
            while (true) {
                synchronized (object) {
                    if (i == 5) {
                        object.notify();
                        try {
                            object.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println(i);
                    i++;
                    i %= 9;
                }
            }
        });

        Thread threadB = new Thread(() -> {
            while (true) {
                synchronized (object) {
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("这是B");
                    object.notify();
                }
            }
        });

        threadA.start();
        threadB.start();
    }
}
```

wait() notify()针对特定的对象，需要先获取锁监视器。



# Synchronized原理解析

> 临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。
>
> **Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。** 对于代码简单的同步块（如被synchronized修饰的getter（）或setter（）方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。



### Synchronized和Lock联系和区别

除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁 （ReentrantLock）来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都 具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁 （lock（）和unlock（）方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：等待可 中断、可实现公平锁，以及锁可以绑定多个条件。

* 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等 待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。

* 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而 非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 

* 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在 synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条 件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则 无须这样做，只需要多次调用newCondition（）方法即可。 



```shell
# 查看class执行的指令码
javac x.java
javap -c    x.class
javap -l x.class
javap -v x.class 
```

### 管程

> Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。

```
public class SynchronizedTest {
    public static void main(String[] args) {
        synchronized (SynchronizedTest.class){

        }
    }
}
```

> javap -c    x.class 结果如下： 为什么有两个monitorexit 管程退出？

```
public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/github/chuangkel/java_learn/base/lock/SynchronizedTest
       2: dup
       3: astore_1
       4: monitorenter
       5: aload_1
       6: monitorexit
       7: goto          15
      10: astore_2
      11: aload_1
      12: monitorexit
      13: aload_2
      14: athrow
      15: return
```

> 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。



### 管程和信号量

> 无论是同步方法还是同步代码块，无论是`ACC_SYNCHRONIZED`还是`monitorenter`、`monitorexit`都是基于`Monitor`实现的

#### 操作系统中的管程

> 管程 (Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比(信号量实现互斥访问？)，管程实现很大程度上简化了程序设计。 管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。



### 对象和管程（Monitor 监视器）

> 每个对象（包括class对象）都有一个监视器。监视器有三部分，比较形象的比喻，special room只能有一个线程持有，wait root是挂起线程的队列，等待队列在hallway。

![1566178299653](/../img/1566178299653.png)

> 在JAVA虚拟机中，每个对象(Object和class)通过某种逻辑关联监视器，为了实现监视器的互斥功能，每个对象(Object和class)都关联着一个监视器，对象可以有它自己的临界区，并且能够监视线程序列为了使线程协作，JAVA提供了wait()和notifyAll以及notify()实现挂起线程、唤醒另外一个等待的线程。

![1566178354439](/../img/1566178354439.png)

和下面的图一样的：

![1566195759821](/../img/1566195759821.png)

### 对象头

| 长度     | 内容                   | 说明                     |
| -------- | ---------------------- | ------------------------ |
| 32/64bit | markword               | 存储hashCode或者锁信息   |
| 32/64bit | class metadata address | 存储到对象类型数据的指针 |
| 32/64bit |                        |                          |





> markword的结构（32位虚拟机，25位存储hashCode,4位存储对象的分代年龄，2位存储锁标志位，1位固定为0，其他位对象不同状态下存储的内容有所不同）

| 存储内容               | 标志位 | 状态       |
| ---------------------- | ------ | ---------- |
| 对象HashCode，分代年龄 | 01     | 未锁定     |
| 指向锁记录的指针       | 00     | 轻量级锁定 |
| 指向重量级锁指针       | 10     | 重量级锁定 |
|                        | 11     | GC         |
| 偏向线程id,偏向时间戳  | 01     | 可偏向     |




锁的升级

偏向锁 -> 轻量级锁->偏向锁->重量级锁

![img](/../img/偏向锁的撤销.png)





![img](/../img/轻量级锁.png)