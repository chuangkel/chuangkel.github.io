---
layout:     post
title:	JVM专题
subtitle: 	
date:       2019-12-24
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---



# 实践

### JVM命令实践

java -Xms2048m -Xmx2048m 会在启动的时候直接创建2048M的堆内存吗（是的，会创建如此的内存大小）

```bash
C:\Users\hspcadmin>java -XX:+PrintCommandLineFlags -version //查看当前jvm所使用的虚拟机
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
-XX:G1ConcRefinementThreads=8 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=131936256 -XX:MaxHeapSize=2110980096 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation
java version "12.0.1" 2019-04-16
Java(TM) SE Runtime Environment (build 12.0.1+12)
Java HotSpot(TM) 64-Bit Server VM (build 12.0.1+12, mixed mode, sharing)
```

HandlePromotionFailure = false //不允许老年代担保失败

DefNew  Default New Gen是 Serial收集器的GC日志中的名称输出

> 开启远程监控管理
>
>  -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8011 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false

### JVM工具



**jstat**

jstat -gcutil pid timeUnit

```shell
[root@logcenter ~]# jstat -gcutil 244766  1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00   0.00  67.58   3.75  93.79  90.09     36    1.021    20    2.436    3.456
  0.00   0.00  67.58   3.75  93.79  90.09     36    1.021    20    2.436    3.456
  0.00   0.00  67.58   3.75  93.79  90.09     36    1.021    20    2.436    3.456
```



**jmap**

jmap -dump:format=b,file=mydump.bin 44679

生成java堆转储快照

jmap -finalizerinfo 44679

显示F-Queue中等待Finalizer线程执行finalize方法的对象，只在Linux/Solaris平台有效。

jmap -heap  44679

显示java堆详细信息，如使用哪种回收器，参数配置，分代状况。只在Linux/Solaris平台有效。

jmap -histo  44679

显示堆中对象统计信息，包括类、实例变量、合计容量

 java -jar websocket-0.0.1-SNAPSHOT.jar  -XX:+HeapDumpOnOutOfMemoryError -XX:+HeapDumpOnCtrlBreak

> -XX:+HeapDumpOnOutOfMemoryError 参数，可以让虚拟机在发生OOM异常出现之后自动生成dump文件
>
> -XX:+HeapDumpOnCtrlBreak 参数，则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，或者在Linux系统下通过Kill -3命令发送进程退出信号"吓唬"一下虚拟机，也能拿到dump文件。



***jhat***

java heap analyse tool，分析jmap -dump 导出的堆镜像文件，可以将堆中的对象以html的形式展现出来

> ./jhat C:\Users\hspcadmin\Desktop\mydump.bin
>
> 不要在生产环境上执行该命令，会消耗机器的性能，如果dump很大，肯能会让服务挂掉。

打开html页面：<http://127.0.0.1:7000/showRoots/>

**jstack**

用于生成虚拟机当前时刻的线程快照。线程快照是虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的是定位线程长时间停顿的原因，如线程间死锁，死循环，请求外部资源导致的长时间等待等都是导致线程长时间等待的原因。线程停顿的时候通过jstack来查看各个线程的堆栈，就知道没有响应的线程到底在做什么操作或者等待什么资源。

 jstack -l 172814

> 查看线程的锁信息。

演示地址：chuangkel\practice-change\practice-change\base-practice\src\main\java\com\github\chuangkel\java\jvm\JstackDemo.java

```java
/** Thread.getAllStackTraces() 通过该方法获取当前虚拟机的所有线程堆栈信息 */
for(Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()){
    Thread t = entry.getKey();
    StackTraceElement[] elements = entry.getValue();
    if(t == Thread.currentThread()){
        continue;
    }
    for(StackTraceElement element : elements){
        System.out.print(element+"\n");
    }
}
```

[](#jump)

### GC实践

**对象占用情况维度**

查看堆内存

jmap

**对象回收情况维度**

查看gc

jstat

CPU**过高维度**

怎样定位到cpu占用高的线程



> GC日志总解

* -XX:+PrintGC 简单打印GC日志

java -jar -XX:+PrintGC  -Xloggc:gclogs.log

### 案例一:如何找到cpu占用率高的那个线程？

> jps -l 可以找到所有的java进程，从中找到需要排除的那个java进程279354  

> top -Hp  279354  #查看279354进程下的线程cup占用情况
>
> 实例中的99.7是死循环中进行了简单的计算

```shell
top - 15:56:55 up 70 days, 43 min,  5 users,  load average: 1.67, 1.85, 1.73
Threads:  66 total,   1 running,  65 sleeping,   0 stopped,   0 zombie
%Cpu(s):  3.3 us,  0.8 sy,  0.0 ni, 95.8 id,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st
KiB Mem : 13124375+total,  8444208 free, 75972632 used, 46826912 buff/cache
KiB Swap: 33554428 total, 32995508 free,   558920 used. 51583172 avail Mem 
   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                    
279431 root      20   0   36.9g 728672  13940 R 99.7  0.6   5:30.90 java                                                       
279354 root      20   0   36.9g 728672  13940 S  0.0  0.6   0:00.00 java                                                               
279355 root      20   0   36.9g 728672  13940 S  0.0  0.6   0:00.15 java                                                               
279356 root      20   0   36.9g 728672  13940 S  0.0  0.6   0:00.04 java    
```

> print "%s/n"  279431 #线程ID十进制转换成十六进制（top得到的是十进制格式的线程ID)

> jstack -l 279354 | grep -C10 44387 # 还是使用jstack -l命令，查看上下10行
>
> 通过多次相同的jstack查看（不同时间点上比较）发现都调用了com.hundsun.websocket.utils.TimerUtil.lambda\$onApplicationEvent$3(TimerUtil.java:79)，检查对应代码是否存在问题

```shell
[root@logcenter ~]# jstack -l 279354 | grep -C10 44387
#...
"我的线程0" #29 prio=5 os_prio=0 tid=0x00007fe4d0e4b000 nid=0x44387 runnable [0x00007fe6585a4000]
   java.lang.Thread.State: RUNNABLE
	at com.hundsun.websocket.utils.TimerUtil.lambda$onApplicationEvent$3(TimerUtil.java:79)
	at com.hundsun.websocket.utils.TimerUtil$$Lambda$10/263019505.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- <0x00000005934286e0> (a java.util.concurrent.ThreadPoolExecutor$Worker)
```

扩展：

> 在jstack dump中，线程一般存在几个状态：分别是RUNNABLE 线程处于执行中，BLOCKED线程被阻塞，WAITING 线程正在等待锁



<span id="jump">跳转到的地方</span>

### 案例二:如何找出死锁的线程？

> 背景知识: nid:是线程的十六进制ID，Locked ownable synchronizers:是线程已持有的锁

```java
private static AtomicInteger ai = new AtomicInteger();
//案例代码
ReentrantLock lock = new ReentrantLock(true);
ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 0L, TimeUnit.MILLISECONDS,
        new ArrayBlockingQueue<>(3), new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(new ThreadGroup("myThreadGroup"),r,"我的线程"+ai.getAndIncrement());
    }
});
executor.submit(()->{
    try{
        lock.lock();
        logger.info("====thread first=====");
    }finally {
        logger.info("thread first finally");
        //lock.unlock();
    }
});
executor.submit(()->{
    lock.lock();
    logger.info("====thread second=====");
});
executor.submit(()->{
    lock.lock();
    logger.info("====thread third=====");
});
```



> 多次运行jstack命令，仍可以看到线程0首先占用了0x000000059366a5c8锁，线程2线程3都在等待该锁(- parking to wait for  <0x000000059366a5c8> (a java.util.concurrent.locks.ReentrantLock$FairSync))
>
> 通过线程jstack dump信息可以定位到具体的代码

```shell

"我的线程2" #31 prio=5 os_prio=0 tid=0x00007f146c049800 nid=0x49fcd waiting on condition [0x00007f14bd2d1000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x000000059366a5c8> (a java.util.concurrent.locks.ReentrantLock$FairSync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
	at java.util.concurrent.locks.ReentrantLock$FairSync.lock(ReentrantLock.java:224)
	at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)
	at com.hundsun.websocket.utils.TimerUtil.lambda$onApplicationEvent$2(TimerUtil.java:67)
	at com.hundsun.websocket.utils.TimerUtil$$Lambda$9/1375452767.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- <0x0000000593677430> (a java.util.concurrent.ThreadPoolExecutor$Worker)

"我的线程1" #30 prio=5 os_prio=0 tid=0x00007f146c048000 nid=0x49fcc waiting on condition [0x00007f14bd3d2000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x000000059366a5c8> (a java.util.concurrent.locks.ReentrantLock$FairSync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
	at java.util.concurrent.locks.ReentrantLock$FairSync.lock(ReentrantLock.java:224)
	at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)
	at com.hundsun.websocket.utils.TimerUtil.lambda$onApplicationEvent$1(TimerUtil.java:63)
	at com.hundsun.websocket.utils.TimerUtil$$Lambda$8/1252911252.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- <0x0000000593674da0> (a java.util.concurrent.ThreadPoolExecutor$Worker)

"我的线程0" #29 prio=5 os_prio=0 tid=0x00007f146c4b3800 nid=0x49fcb runnable [0x00007f14bd4d3000]
   java.lang.Thread.State: RUNNABLE
	at com.hundsun.websocket.utils.TimerUtil.lambda$onApplicationEvent$3(TimerUtil.java:79)
	at com.hundsun.websocket.utils.TimerUtil$$Lambda$10/263019505.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
	- <0x000000059366a5c8> (a java.util.concurrent.locks.ReentrantLock$FairSync)
	- <0x0000000593672648> (a java.util.concurrent.ThreadPoolExecutor$Worker)
```



### 案例三:

GC收集器 Serial + Serial Old

-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8

固定堆内存20M，新生代10M，剩下的老年代10M，新生代中Eden:Survivor=8:1 ,Eden 8M,Survivor 1M

> vm参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728
>
> -XX:PretenureSizeThreshold=3145728 //超过3M直接进入老年代
>
> -XX:+UseSerialGC //指定GC收集器 ，该参数指定了Serial + Serial Old收集器的组合

实验代码

```java
public class JVMDemo {
    public static void main(String[] args) {
        int m1 = 1024 * 1024;
        byte[] b1 = new byte[m1 * 2];
        byte[] b2 = new byte[m1 * 2];
        byte[] b3 = new byte[m1 * 2];
        byte[] b4 = new byte[m1 * 4]; //直接进入老年代
    }
}
```

实际允许参数命令：

```
java -verbose:gc -Xms20M -Xmx20M -Xmn10
M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC  JVMDemo
```

实验结果:遇到大对象直接移到老年代，-Xmn10M年轻代空间为10M,总的堆空间20M,所以老年代空间10M

```
[0.008s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.
[0.031s][info   ][gc] Using Serial
 Heap address: 0x00000000fec00000, size: 20 MB, Compressed Oops mode: 32-bit
 Heap
 def new generation   total 9216K, used 7731K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
 eden space 8192K,  94% used [0x00000000fec00000, 0x00000000ff38cf98, 0x00000000ff400000)
 from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x000000010000000
 Metaspace       used 244K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 12K, capacity 386K, committed 512K, reserved 1048576K
```

问题1 指定了 -Xms20M -Xmx20M 堆内存会超过20M吗，若程序允许需要超过20M的内存会报什么错？

```
//实验创建21M大小的对象，报错如下
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
        at JVMDemo.main(JVMDemo.java:13)
//由此可见，堆内存的大小设置直接关乎程序运行的稳定性情况，设置不当直接会影响程序的运行
```

### 案例四:Jstack实践

案例来源：深入理解Java虚拟机%20JVM高级特性与最佳实践.pdf 周志明

测试代码：

```java
public class JstackLockAndWhileTrueDemo {

    public static void createLockThread(Object obj)  {
        new Thread(()->{
            synchronized (obj){
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"myLockThread").start();
    }
    public static void createBusyThread(){
        new Thread(()->{
            while (true){
                ;
            }
        },"myBusyThread").start();
    }
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        reader.readLine();
        createBusyThread();
        reader.readLine();
        createLockThread(new Object());
    }
}
```

io输入不应该会阻塞吗，为什么这里是RUNNABLE状态呢？ 同时通过top命令或者jconsole监控看到等待io输入的线程并没有占用什么cpu使用率，这是怎么做到的呢？

```
名称: main
状态: RUNNABLE
总阻止数: 0, 总等待数: 0

堆栈跟踪: 
java.io.FileInputStream.readBytes(Native Method)
java.io.FileInputStream.read(FileInputStream.java:255)
java.io.BufferedInputStream.read1(BufferedInputStream.java:284)
java.io.BufferedInputStream.read(BufferedInputStream.java:345)
   - 已锁定 java.io.BufferedInputStream@700e4ade
sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
   - 已锁定 java.io.InputStreamReader@48fbbb9e
java.io.InputStreamReader.read(InputStreamReader.java:184)
java.io.BufferedReader.fill(BufferedReader.java:161)
java.io.BufferedReader.readLine(BufferedReader.java:324)
   - 已锁定 java.io.InputStreamReader@48fbbb9e
java.io.BufferedReader.readLine(BufferedReader.java:389)
com.github.chuangkel.java.jvm.JstackLockAndWhileTrueDemo.main(JstackLockAndWhileTrueDemo.java:33)
```



cpu占用率12.6%，测试机器8核，一个线程死循环将该cpu打满了，1/8 约12.6%，测试笔记本的cpu物理核数是8

```
名称: myBusyThread
状态: RUNNABLE
总阻止数: 0, 总等待数: 0

堆栈跟踪: 
com.github.chuangkel.java.jvm.JstackLockAndWhileTrueDemo.lambda$createBusyThread$1(JstackLockAndWhileTrueDemo.java:26)
com.github.chuangkel.java.jvm.JstackLockAndWhileTrueDemo$$Lambda$8/1229416514.run(Unknown Source)
java.lang.Thread.run(Thread.java:748)
```

可以看到wait让线程等待了

```
名称: myLockThread
状态: java.lang.Object@43ebe0ed上的WAITING
总阻止数: 0, 总等待数: 1

堆栈跟踪: 
java.lang.Object.wait(Native Method)
java.lang.Object.wait(Object.java:502)
com.github.chuangkel.java.jvm.JstackLockAndWhileTrueDemo.lambda$createLockThread$0(JstackLockAndWhileTrueDemo.java:17)
com.github.chuangkel.java.jvm.JstackLockAndWhileTrueDemo$$Lambda$9/2016447921.run(Unknown Source)
java.lang.Thread.run(Thread.java:748)
```



linux上运行案例代码：

> printf "%x" 328740 
> 50424
>
>  jstack -l 328684  | grep -C10  50424

```
[root@logcenter ~]# jstack -l 328684  | grep -C10  50424
//...
"myBusyThread" #21 prio=5 os_prio=0 tid=0x00007f4ee01b8800 nid=0x50424 runnable [0x00007f4eb0ecd000]
   java.lang.Thread.State: RUNNABLE
	at JstackLockAndWhileTrueDemo.lambda$createBusyThread$1(JstackLockAndWhileTrueDemo.java:25)
	at JstackLockAndWhileTrueDemo$$Lambda$1/834600351.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
	- None
	//...
```

top命令监控当死循环线程将单个cpu打到了99.7%，jconsole工具监控到cpu占用率2.1%

```shell
[root@logcenter ~]# top -Hp 328684
top - 17:14:08 up 78 days,  2:01,  6 users,  load average: 2.25, 2.12, 1.70
Threads:  64 total,   1 running,  63 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4.5 us,  1.2 sy,  0.0 ni, 94.0 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
KiB Mem : 13124375+total,  3564732 free, 74896464 used, 52782560 buff/cache
KiB Swap: 33554428 total, 33002932 free,   551496 used. 52512956 avail Mem 

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                            
328740 root      20   0   36.7g 117000  13144 R 99.7  0.1  10:47.46 java                                                               
328731 root      20   0   36.7g 117000  13144 S  0.3  0.1   0:00.24 java                                                               
328684 root      20   0   36.7g 117000  13144 S  0.0  0.1   0:00.00 java                                                               
328685 root      20   0   36.7g 117000  13144 S  0.0  0.1   0:00.11 java
```


猜想： 可以通过死循环打满单个cpu，通过jconsole监控cpu占用率来计算机器的逻辑cpu核总数。

上例中， 100/2.1 = 50 ,所以cpu和逻辑核数大概在50左右。通过查看实验机器上的逻辑核数，果然和猜想的基本一致，这会是巧合吗？理论上应该是符合的。

> [root@logcenter ~]# cat /proc/cpuinfo| grep "processor"| wc -l 
> 48

### 案例五:线程死锁相互等待

案例来源：深入理解Java虚拟机%20JVM高级特性与最佳实践.pdf 代码清单4-10

代码：

```java
/**
 * 线程死锁演示
 * @author lpc
 * @version $Id: LockThreadDemo.java, v 0.1 2020年05月26日 17:38:35 23911 Exp $
 */
public class LockThreadDemo {

    static class Task implements Runnable{
        int a,b;
        public Task(int a,int b){
            this.a = a;
            this.b = b;
        }
        @Override
        public void run() {
            synchronized (Integer.valueOf(a)){
                synchronized (Integer.valueOf(b)){
                    System.out.println(a+b);
                }
            }
        }
    }
    public static void main(String[] args) {
        for(int i = 0; i < 3;i++){
            new Thread(new Task(1,2)).start();
            new Thread(new Task(2,1)).start();
        }
    }
}
```



可以看到线程Thread-3 和 Thread-4相互等待对方的资源释放，Thread-3已锁定的Integer@7824b575对象是Thread-4请求的对象，Thread-4锁定的对象Integer@78095ae8是Thead-3请求的对象。线程状态为BLOCKED

```
名称: Thread-3
状态: java.lang.Integer@78095ae8上的BLOCKED, 拥有者: Thread-4
总阻止数: 2, 总等待数: 0

堆栈跟踪: 
com.github.chuangkel.java.jvm.LockThreadDemo$Task.run(LockThreadDemo.java:20)
   - 已锁定 java.lang.Integer@7824b575
java.lang.Thread.run(Thread.java:748)
------------------------------------------------------
名称: Thread-4
状态: java.lang.Integer@7824b575上的BLOCKED, 拥有者: Thread-3
总阻止数: 2, 总等待数: 0

堆栈跟踪: 
com.github.chuangkel.java.jvm.LockThreadDemo$Task.run(LockThreadDemo.java:20)
   - 已锁定 java.lang.Integer@78095ae8
java.lang.Thread.run(Thread.java:748)
```

死锁原因，Integer.valueOf会将[-2^8,2^8-1]即[-128,127]的数缓存起来，当valueOf()传入的参数在这个范围之内时，会直接返回之前缓存的对象。



### 案例六:visualVM实践

>  插件下载地址：<https://visualvm.github.io/archive/uc/7u60/updates.html>

**BTrace 工具实践**

通过HotSwap技术动态加入原本不存在的代码，可以在不停机的条件下实现线上调试。

实验代码：

```java
public class BtraceDemo {
    public int add(int a,int b){
        return a+b;
    }
    public static void main(String[] args) throws IOException {
        BtraceDemo demo = new BtraceDemo();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        reader.readLine();
        for(int i = 0; i < 3; i++){
            int a =(int)Math.round(Math.random() * 1000);
            int b =(int)Math.round(Math.random() * 1000);
            System.out.println(demo.add(a,b));
        }
    }
}
```

脚本：

```java
/* BTrace Script Template */
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;
import com.sun.btrace.AnyType;

@BTrace
public class TracingScript {
	/* put your code here */
 	@OnMethod(clazz = "com.github.chuangkel.java.jvm.BtraceDemo",method="add",location=@Location(Kind.RETURN))
    public static void m0(AnyType[] args, @Duration long duration) {
        println("\n==== com.github.chuangkel.java.jvm.BtraceDemo#add ====");
		println("耗时："+duration);
        printArray(args);
        jstack();
    }
}

```

脚本快捷生成工具：

> <https://btrace.org/btrace/?spm=5176.100239.blogcont7569.12.ndJs5r>

输出：

```
* Starting BTrace task
** Compiling the BTrace script ...
*** Compiled
** Instrumenting 1 classes ...
*** Done
** BTrace up&running

*** Done
** BTrace up&running


==== com.github.chuangkel.java.jvm.BtraceDemo#add ====
耗时：300
[982, 197, ]
com.github.chuangkel.java.jvm.BtraceDemo.add(BtraceDemo.java:14)
com.github.chuangkel.java.jvm.BtraceDemo.main(BtraceDemo.java:24)

==== com.github.chuangkel.java.jvm.BtraceDemo#add ====
耗时：100
[964, 734, ]
com.github.chuangkel.java.jvm.BtraceDemo.add(BtraceDemo.java:14)
com.github.chuangkel.java.jvm.BtraceDemo.main(BtraceDemo.java:24)

==== com.github.chuangkel.java.jvm.BtraceDemo#add ====
耗时：100
[974, 511, ]
com.github.chuangkel.java.jvm.BtraceDemo.add(BtraceDemo.java:14)
com.github.chuangkel.java.jvm.BtraceDemo.main(BtraceDemo.java:24)
** BTrace has stopped
** BTrace has stopped
```



# 理论

### java.lang.Object#finalize

> 使用场景：进行一些收尾的工作，比如：关闭一些不属于jvm管理的资源，比如native方法free空间

* finalize()方法 通过将调用f方法的对象赋值给gc roots可达的对象中的引用，从而复活。

* 程序员和jvm都能调用该方法，jvm最多只会调用该方法一次，相互不影响。
* finalize()方法是在低优先级线程中执行的，可能带来低性能
* 不能保证finalize()方法会被即使地执行或者不能保证其一定执行



该方法涉及 gc回收过程、对象状态变迁

**F状态空间：**unfinazed对象不准备执行finalize()方法、finalizable 对象不可达可以执行finalize()方法、finalized已经执行f方法

**R状态空间：**reachable对象可达、finalizer-reachable 即finalizer可达、unreachable对象不可达

> 对象可达：finalizer-reachable 和 用户对象-reachable，都不可回收

> 可回收的状态空间组合：unreachable

jmap -finalizerInfo pid //显示F-Queue中等待Finalizer线程执行finalize方法的对象

例子：com.github.chuangkel.java.jvm.GcDemo

```java
public class GcDemo {

    private static GcDemo hook = null;
    public static void main(String[] args) throws InterruptedException {
        hook = new GcDemo();
        hook = null;
        System.gc();//gc()执行时，同时执行了finalize() 只会执行一次
        Thread.sleep(2000L);
        if(null == hook){
            System.out.println("I am dead");
        }else{
            System.out.println("I am living");
        }
        hook = null;
        System.gc();//gc()执行时，同一个对象已经执行了一次finalize() ，这里不再执行finalize() 
        Thread.sleep(2000L);
        if(null == hook){
            System.out.println("I am dead");
        }else{
            System.out.println("I am living");
        }

    }

    /**
     * GcDemo#finalize() 方法只能被jvm调用一次，对象在该方法被复活之后，后续的gc() jvm不会再执行该方法了。
     * 用户对该方法的调用不影响jvm的调用
     * @throws Throwable
     */
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("com.github.chuangkel.java.jvm.GcDemo.finalize...");
        hook = this;
    }
}
/**运行结果：
com.github.chuangkel.java.jvm.GcDemo.finalize...
I am living
I am dead*/
```



### 虚拟机执行子系统

#### 类文件结构

类文件结构中组成部分的排列顺序是**魔术和Class文件的版本，常量池，访问标志，类索引父类索引与接口索引集合，字段表集合，方法表集合，属性表集合**

* 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）
* 实现语言无关性的基础仍然是**虚拟机和字节码存储格式**。Java虚拟机不和包括Java在内的任何语言绑定，**java虚拟机只与“Class文件”这种特定的二进制文件格式所关联**，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，**虚拟机并不关心Class的来源是何种语言**。
* Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。
* 任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。
* Class文件是一组以**8bit即一个字节为基础单位的二进制流，u1、u2、u4、u8 分别代表1、2、4、8个字节**，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
* 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有**两种数据类型：无符号数和表**，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。
* **无符号数属于基本的数据类型**，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
* **表是由多个无符号数或者其他表作为数据项构成的复合数据类型**，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

### 魔数与Class文件的版本



### 常量池

javac JavapTest.java

javap -verbose JavaTest.class

```java
public class JavapTest {
    int a = 1;
    int aa = 2;
}
```

```
  MD5 checksum 58b88c85c197d544ff05d0dd49d96580
  Compiled from "JavapTest.java"
public class com.github.chuangkel.java_learn.base.bases.JavapTest
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #4                          // com/github/chuangkel/java_learn/base/bases/JavapTest
  super_class: #5                         // java/lang/Object
  interfaces: 0, fields: 2, methods: 1, attributes: 1
Constant pool:
   #1 = Methodref          #5.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #4.#16         // com/github/chuangkel/java_learn/base/bases/JavapTest.a:I
   #3 = Fieldref           #4.#17         // com/github/chuangkel/java_learn/base/bases/JavapTest.aa:I
   #4 = Class              #18            // com/github/chuangkel/java_learn/base/bases/JavapTest
   #5 = Class              #19            // java/lang/Object
   #6 = Utf8               a
   #7 = Utf8               I
   #8 = Utf8               aa
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               SourceFile
  #14 = Utf8               JavapTest.java
  #15 = NameAndType        #9:#10         // "<init>":()V
  #16 = NameAndType        #6:#7          // a:I
  #17 = NameAndType        #8:#7          // aa:I
  #18 = Utf8               com/github/chuangkel/java_learn/base/bases/JavapTest
  #19 = Utf8               java/lang/Object
{
  int a;
    descriptor: I
    flags: (0x0000)

  int aa;
    descriptor: I
    flags: (0x0000)

  public com.github.chuangkel.java_learn.base.bases.JavapTest();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field a:I
         9: aload_0
        10: iconst_2
        11: putfield      #3                  // Field aa:I
        14: return
      LineNumberTable:
        line 9: 0
        line 10: 4
        line 11: 9
}
SourceFile: "JavapTest.java"
```

常量池可以分成两部分，字面量和符号引用。每个类型都是一个表，由u结构或u和表结构构成。每种常量池的结构的命名都是以_info结尾的，表示是一个表结构。

字面量：文本字符串和final常量。

符号引用：类和接口符号引用、方法符号引用、字段符号引用。

常量池的分类：CONSTANT_Utf8_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Double_info、CONSTANT_String_info（字节码中的，在运行时存放在堆中）、CONSTANT_Class_info、CONSTANT_Methodref_info、CONSTANT_Fieldref_info、CONSTANT_Interface_Method_info、CONSTANT_NameAndType_info(字段和字段类型对应关系常量池)、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_Invoke_Dynamic_info。

CONSTANT_Utf8_info是作为其他常量池表结构中的一部分(基础部分)，即其他的常量池比如CONSTANT_Class_info中指向了CONSTANT_Utf8_info中的地址。

![1569652816366](/../img/1569652816366.png)

### 访问标识

常量池之后紧接着是两个字节的访问标识(assecc flags)，用于描述改字节码文件是类还是接口，和访问的权限（public或者是default包默认访问级别）是否是final,是否是abstract等。

![1569653164983](/..\img\1569653164983.png)

### 类索引、父类索引、接口索引集合

类索引和父类索引都是一个u2的数据，而接口索引集合是一组u2的数据。类索引为例，它指向的是常量池的CONSTANT_Class_info表里的数据行a,该数据a再指向常量池的CONSTANT_Utf8_info里面的数据行。父类索引用于确定这个类的全限定名，没有继承默认的父类为Object，Object的父类索引为空。

### 字段表集合

![1569657050063](/..\img\1569657050063.png)

字段类型

字段的修饰符 public、private、protected,默认包类型,；static;final;transient;voliate;

![1569653997069](/..\img\1569653997069.png)



### 方法表集合

方法表结构

![1569656980205](/..\img\1569656980205.png)

方法的修饰符 private,protected,public;synchronized;final;static;

![1569657010832](/..\img\1569657010832.png)

### 属性表集合

#### Code属性

Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。整个class文件分为元数据和代码，这个代码就是code索性，可见其重要性。

![1569682510429](/..\img\1569682510429.png)

1. **attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”**，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。
2. **max_stack代表了操作数栈（Operand Stacks）深度的最大值**。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（StackFrame）中的操作栈深度。
3. **max_locals代表了局部变量表所需的存储空间**。在这里，max_locals的单位是**Slot**,Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。**方法参数（包括实例方法中的隐藏参数“this”）**、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、**方法体中定义的局部变量都需要使用局部变量表来存放**。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。
4. **code_length和code用来存储Java源程序编译后生成的字节码指令**。code_length代表字节码长度，**code是用于存储字节码指令的一系列字节流**。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个**u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令**。（对于二进制来说：8位二进制即一个字节，一个字节的二进制可表达的范围：0b00000000~0b11111111，一个字节用十六进制表达：0x00~0xFF（4bit为一个占位）     扩展：  一字节可表示有符号十进制范围：-128~127（计算机中一律采用补码来表示数值。一个负数=改负数的绝对值的补码=即该绝对值的反码+1））

> 扩展：计算机中一律采用补码来表示数值。一个负数=改负数的绝对值的补码=即该绝对值的反码+1
>
> 
>
> 原因：由于计算机寄存器存储位数有限。cpu既要设计加法又要设计减法，代价有点大，所以考虑把减法变成加法，那怎么实现呢？
>
> 规定正数的补码等于原码，补码中最高位0表示正数
>
> 规定负数的补码等于原码取反码+1，补码中最高位1表示负数
>
> 这样就只有加法了。
>
> 模的概念：时钟一共360度，但是365度是存在的，它和5度是一样的。 -30度表示逆时针转30度，也可顺时针转330度。 整个能表示的长度是360. 如：50度减去30度（50度加330度然后取模360 = 20度），计算机的位长度也是有限的，一字节八位能表示的总长度是256.
>
> 如：5-3=2。计算： (5+(256-3))mod 256=2
>
> 5 =0b0000 0101
>
> -3即3的反码加1 。3 =0b0000 0011 。 -3 = 0b1111 1101 
>
> 0b0000 0101
>
> 0b1111 1101 
>
> 0b0000 0010（结果）



Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。

#### Execption属性



## 虚拟机类加载机制

> - 代码编译的结果是把机器码转换成了字节码（class文件），是存储格式的一小步，确实编程语言进步的一大步。
> - 类加载机制就是将字节码（class文件）加载进虚拟机。



* class文件描述的各种信息，最终都需要加载到虚拟机中才能运行和使用。
* 虚拟机的类加载机制：虚拟机把描述类的数据加载进内存，并对数据进行校验 ，转换解析并进行初始化，最终形成java虚拟机可以使用的java类型，这就是java虚拟机的类加载机制。

* 类的加载过程：加载、验证、准备、解析、初始化



### 类加载过程

类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。

#### 加载

这是类加载过程的第一个阶段，工程师对程序的控制性也最强，可以定义Class字节码文件的来源（网络、数据库或文件）。类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。自定义类加载器只需重写一个类加载器的loadClass()方法。

把Class二进制文件加载进方法区。

#### 验证

对方法区的Class二进制文件进行校验。

#### 准备

准备阶段是正式为类变量**分配内存**并**设置类变量初始值**的阶段，这些变量所使用的内存都将在**方法区**中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的**初始值**“通常情况”下是数据类型的**零值**，假设一个类变量的定义为

```java
public static int VALUE = 123;
```

那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于**类构造器＜clinit＞()**方法之中，所以把value**赋值为123**的动作将在**初始化阶段**才会执行。

在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：

```java
public final static int VALUE = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

#### 解析

解析阶段是虚拟机将常量池内的**符号引用替换为直接引用**的过程，在这个阶段，类装入器装入类所引用的其他所有类。可以用许多方式引用类：超类、接口、字段、方法签名、方法中使用的本地变量。

符号引用：它是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能够无歧义地定位到目标即可。符号引用与虚拟机内存布局无关，符号引用的类并不一定加载到内存中。比如：CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

直接引用：与虚拟机内存有关，直接引用的内一定加载到内存中了。可以是：1. 直接指向目标的指针，比如类，类对象，类成员变量，类方法  2. 相对偏移量，比如实例方法、实例变量的直接引用都是偏移量 3. 一个能间接定位到的句柄。

#### 初始化

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：**初始化阶段**是**执行类构造器＜clinit＞()**方法的过程。

＜clinit＞()方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块（static{}块）**中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```java
public class Test{
    static{
    i=0；//给变量赋值可以正常编译通过
    System.out.print（i）；//这句编译器会提示"非法向前引用"  编译报错：Illegal forward reference
    }
    static int i=1；
}
```

＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。由于父类的＜clinit＞()方法先执行，也就意味着**父类中定义的静态语句块要优先于子类的静态语句块操作**。

```java
static class Parent{
    public static int A=1；
    static{
    A=2；
    }
}
static class Sub extends Parent{
    public static int B=A；
    }
    public static void main（String[]args）{
    System.out.println（Sub.B）；
}
```



构造器和静态块的执行先后顺序，静态块在类加载过程中的初始化阶段执行，先于类构造器执行，类的构造器是在创建对象的时候执行。 父类的今天静态块先于子类的静态块执行。

```java
//com.github.chuangkel.java.base.StaticClinitMain
public class StaticClinitMain {
    public static void main(String[] args) {
        System.out.println("main...");
        new StaticClinitDemo();
    }
}
//com.github.chuangkel.java.base.StaticClinitDemo
public class StaticClinitDemo {
    public StaticClinitDemo() {
        System.out.println("constructor...");
    }

    static {
        System.out.println("static ...");
    }
}
/**结果：
main...
static ...
constructor...
*/
```

＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。

虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

```java
static class DeadLoopClass{
    static{
        /*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/
        if（true）{
            System.out.println（Thread.currentThread（）+"init DeadLoopClass"）；
            while（true）{
            }
        }
    }
}
public static void main（String[]args）{
    Runnable script=new Runnable（）{
        public void run（）{
            System.out.println（Thread.currentThread（）+"start"）；
            DeadLoopClass dlc=new DeadLoopClass（）；
            System.out.println（Thread.currentThread（）+"run over"）；
        }
    }；
    Thread thread1=new Thread（script）；
    Thread thread2=new Thread（script）；
    thread1.start（）；
    thread2.start（）；
}
//Thread[Thread-0，5，main]start
//Thread[Thread-1，5，main]start
//Thread[Thread-0，5，main]init DeadLoopClass
```

案例变种：

```java
class DeadLoopClass {
    static {
        //多次实例化 只执行了一次
        System.out.println(Thread.currentThread() + "init DeadLoopClass");
    }

    public static void main(String[] args) {
        Runnable script = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread() + "start");
                DeadLoopClass dlc = new DeadLoopClass();
                System.out.println(Thread.currentThread() + "run over");
            }
        };
        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start();
        thread2.start();
    }
}
/** 结果：
Thread[main,5,main]init DeadLoopClass
Thread[Thread-0,5,main]start
Thread[Thread-1,5,main]start
Thread[Thread-0,5,main]run over
Thread[Thread-1,5,main]run over */
```

到此，类已经完整装入，可以使用了。

类装入的方式有两种 —— *显式* 或 *隐式*，两者之间有些细微差异。

***显式类装入***发生在使用以下方法调用装入的类的时候：

- `cl.loadClass()`（`cl` 是 `java.lang.ClassLoader` 的实例）
- `Class.forName()`（启动的类装入器是当前类定义的类装入器）

当调用其中一个方法的时候，指定的类（以类名为参数）由类装入器装入。如果类已经装入，那么只是返回一个引用；否则，装入器会通过委托模型装入类。

***隐式类装入***发生在由于引用、实例化或继承导致装入类的时候（不是通过显式方法调用）。在每种情况下，装入都是在幕后启动的，JVM 会解析必要的引用并装入类。与显式类装入一样，如果类已经装入了，那么只是返回一个引用；**否则，装入器会通过委托模型装入类。**

类的装入通常组合了显式和隐式类装入。例如，类装入器可能先显式地装入一个类，然后再隐式地装入它引用的所有类。





#### 为什么要自定义类加载器 

- 可以对Class字节码文件进行加密和解密
- 自定义Class字节码文件来源

### 类加载器

> 类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然目前Java Applet技术基本上已经“死掉”，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。

### 类和类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，`只要加载它们的类加载器不同，那这两个类就必定不相等`。

这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

```java
/**
 * @author lpc
 * @version $Id: ClassLoaderTest.java, v 0.1 2020年05月29日 09:42:14 lpc Exp $
 */
public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader myLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class";
                    InputStream is = getClass().getResourceAsStream(fileName);
                    if (is == null) {
                        return super.loadClass(name);
                    }
                    byte[] b = new byte[is.available()];
                    is.read(b);
                    return defineClass(name, b, 0, b.length);
                } catch (IOException e) {
                    throw new ClassNotFoundException(name);
                }
            }
        };
        Object obj = myLoader.loadClass("com.github.chuangkel.java.jvm.BtraceDemo").newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof com.github.chuangkel.java.jvm.BtraceDemo);
        Object newObj = new BtraceDemo();
        System.out.println("newObj instanceof com.github.chuangkel.java.jvm.BtraceDemo: " + (newObj instanceof com.github.chuangkel.java.jvm.BtraceDemo));
        Object newObj1 = new GcDemo();
        System.out.println("newObj1 instanceof com.github.chuangkel.java.jvm.BtraceDemo : " + (newObj1 instanceof com.github.chuangkel.java.jvm.BtraceDemo));
        /** instanceof 类型 + 类加载器 相同才能视为属于该类型*/
    }
/**输出结果：
class com.github.chuangkel.java.jvm.BtraceDemo
false
newObj instanceof com.github.chuangkel.java.jvm.BtraceDemo: true
newObj1 instanceof com.github.chuangkel.java.jvm.BtraceDemo : false
*/
```



Bootstrap ClassLoader

Extension ClassLoader

Application ClassLoader

XXXClassLoader

#### 双亲委派模型

从Java虚拟机的角度来讲，只存在两种不同的类加载器：

一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；

另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。

`启动类加载器（Bootstrap ClassLoader）`：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

`扩展类加载器（Extension ClassLoader）`：这个加载器由sun.misc.Launcher\$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

`应用程序类加载器（Application ClassLoader）`：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。

> 三种类加载器实验：输出三种不同的类加载器

```java
/**
 * @author lpc
 * @version $Id: BootstrapClassLoaderDemo.java, v 0.1 2020年06月04日 17:30:58 lpc Exp $
 */
public class BootstrapClassLoaderDemo {

    public static void main(String[] args) {
        //java.lang.Object ，位于rt.jar包下，对应目录 \jdk1.8.0_251\jre\lib
        Object obj = new Object();
        System.out.println(obj.getClass().getClassLoader());
        //sun.misc.Timer，位于rt.jar包下，对应目录 \jdk1.8.0_251\jre\lib
        Timer unsafe = new Timer(null,1L);
        System.out.println(unsafe.getClass().getClassLoader());
        //com.sun.java.accessibility.util.java.awt.LabelTranslator ，对应目录jdk1.8.0_251\jre\lib\ext 
        LabelTranslator labelTranslator = new LabelTranslator();
        System.out.println(labelTranslator.getClass().getClassLoader());
        //com.github.chuangkel.java.jvm.BtraceDemo
        BtraceDemo obj1 = new BtraceDemo();
        System.out.println(obj1.getClass().getClassLoader());
    }
}
/** 输出：
null
null //最上层的类加载器，加载jre/lib/目录下的所有类文件
sun.misc.Launcher$ExtClassLoader@27c170f0 //加载jre/lib/ext/目录下的所有类文件
sun.misc.Launcher$AppClassLoader@18b4aac2 //若开发者没自定义类加载器，由该类加载器加载用户自定义类
*/
```

#### 为什么要有双亲委派模型？

> 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
>
> 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。**例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类**。
>
> 双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中，如代码清单如下所示，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。

```java
//java.lang.ClassLoader#loadClass(java.lang.String, boolean) 
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            //首先，检查请求的类是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    //如果父类加载器抛出ClassNotFoundException
                	//说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    //在父类加载器无法加载的时候
               		//再调用本身的findClass方法来进行类加载
                    long t1 = System.nanoTime();
                    c = findClass(name);
                    // ...
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```





#### 双亲委派模型的破坏

为什么会破坏双亲委派模型？ 3次破坏

1. java.lang.ClassLoader （@since 1.0），而双亲委派模型是jdk1.2引入的，对jdk1.0的ClassLoader做了妥协（集成ClassLoader重新loadClass()方法，jvm加载的时候调用loadClass方法获取字节码文件）

2. 第二次是双亲委派模型自身的缺陷所致的，双亲委派模型很好地解决了各个加载器加载基础类的同一问题，基础类都委派上层的父类加载器加载，但是当基础类回调用户的代码，怎么办？，比如jndi（jndi的目的是对资源进行集中管理和加载，它需要调用由独立厂商实现并部署在应用程序的Classpath下的jndi接口提供者的代码，但启动类加载器并不认识这些代码）

   解决： java团队引入了线程上下文加载器（Thread Context ClassLoader)，这个类通过java.lang.Thread#setContextClassLoader 方法进行设置，如果创建线程未设置，则集成父线程中的ClassLoader,若应用程序全范围内都没有设置过，则默认为应用程序加载器（Bootstrap ClassLoader、ExtensionClassLoader、Application ClassLoader(默认)）

   有了线程上下文加载器，jndi服务就可以使用它去加载所需要的SPI代码，即父 类加载器委托子 类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用自定义的类加载器，实际上违背了双亲委派模型的一般性原则，java中所有涉及spi的代码的加载操作都采用这种方式，如jndi,jdbc,jce,jaxb,jbi等。

   

3. 第三次破坏则是用户对代码热替换，模块热部署的追求，做到部署之后机器不重启就能使用代码。OSGI实现热部署的关键是它自定义类加载器机制的实现。每一个程序模块（bundle)都有自己自定义的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。







**破坏双亲委派模型**

双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？
这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK 1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？
为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。
双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一
次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。
Sun公司所提出的JSR-294[1]、JSR-277[2]规范在与JCP组织的模块化规范之争中落败给JSR291（即OSGi R4.2），虽然Sun不甘失去Java模块化的主导权，独立在发展Jigsaw项目，但目前OSGi已经成为了业界“事实上”的Java模块化标准[3]，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：
1）将以java.*开头的类委派给父类加载器加载。
2）否则，将委派列表名单内的类委派给父类加载器加载。
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的
类加载器加载。
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7）否则，类查找失败。
上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类
加载器中进行的。
OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类
加载器的精髓。

#### 扩展

`JNDI (Java Naming and Directory Interface)`在 J2EE 中的角色就是“交换机” —— J2EE 组件在运行时间接地查找其他组件、资源或服务的通用机制。在多数情况下，提供 JNDI 供应者的容器可以充当有限的数据存储，这样管理员就可以设置应用程序的执行属性，并让其他应用程序引用这些属性（Java 管理扩展（Java Management Extensions，JMX）也可以用作这个目的）JNDI 在 J2EE 应用程序中的主要角色就是提供间接层，这样组件就可以发现所需要的资源，而不用了解这些间接性。

 JBoss 和 Net Beans，都拥有一套自定义的组件开发规范和框架，但是实际上这些解决方案都是基于为组件分配独立的类加载器 (Class Loader) 的思想。 OSGi 框架为基于 Java 的组件开发提供了一套通用的和标准的解决方案，并已经成为事实上的工业标准。





----------------------------------

**字节码提升？**

Java是一门静态语言，通常class在编译的时候就已经生成了，为什么有时候我们还想在运行时动态生成class呢？因为在有些时候得在运行时为一个类动态创建子类。比如编写一个ORM框架，如何得知一个简单的JavaBean是否被用户修改过呢？

其实`UserProxy`实现起来很简单，就是创建一个`User`的子类，覆写所有`setXxx()`方法，做个标记就可以了：


  但是这个`UserProxy`就必须在运行时动态创建出来了，因为编译时ORM框架根本不知道`User`类。

现在问题来了，动态生成字节码，难度有多大？

如果我们要自己直接输出二进制格式的字节码，在完成这个任务前，必须先认真阅读[JVM规范第4章](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)，详细了解class文件结构。估计读完规范后，两个月过去了。



第一种方法，自己动手，从零开始创建字节码，理论上可行，实际上很难。

第二种方法，使用已有的一些能操作字节码的库，帮助我们创建class。

目前，能够操作字节码的开源库主要有[CGLib](https://github.com/cglib/cglib)和[Javassist](http://jboss-javassist.github.io/javassist/)两种，它们都提供了比较高级的API来操作字节码，最后输出为class文件。

比如CGLib，典型的用法如下：  

换一个思路，如果我们能创建`UserProxy.java`这个源文件，再调用Java编译器，直接把源码编译成class，再加载进虚拟机，任务完成！

毕竟，创建一个字符串格式的源码是很简单的事情，就是拼字符串嘛，高级点的做法可以用一个模版引擎。

如何编译？

Java的编译器是`javac`，但是，在很早很早的时候，Java的编译器就已经用纯Java重写了，自己能编译自己，行业黑话叫“自举”。从Java 1.6开始，编译器接口正式放到JDK的公开API中，于是，我们不需要创建新的进程来调用`javac`，而是直接使用编译器API来编译源码。

使用起来也很简单：

```
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
int compilationResult = compiler.run(null, null, null, '/path/to/Test.java');
```

 

这么写编译是没啥问题，问题是我们在内存中创建了Java代码后，必须先写到文件，再编译，最后还要手动读取class文件内容并用一个ClassLoader加载。

> 有木有更简单的方法？

有！

其实Java编译器根本不关心源码的内容是从哪来的，你给它一个`String`当作源码，它就可以输出`byte[]`作为class的内容。

所以，我们需要参考Java Compiler API的文档，让**Compiler直接在内存中完成编译，输出的class内容就是`byte[]`**。

代码改造如下：

> 除了写ORM用之外，还能干什么？

* 可以用它来做一个Java脚本引擎？



代码例子？

后续....

### 

# 指令重排

final 

volatile



```java
/**
 * 指令重排 实践
 * @author lpc
 * @version $Id: InstructionRearrangementDemo.java, v 0.1 2020年07月25日 09:00:28 lpc Exp $
 */
public class InstructionRearrangementDemo {
    private static int x = 0, y = 0;
    private static int a = 0, b =0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for(;;) {
            i++;
            x = 0; y = 0;
            a = 0; b = 0;
            Thread one = new Thread(new Runnable() {
                @Override
                public void run() {
                    //由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.
                    shortWait(50000);
                    //1,2操作不存在数据依赖，存在重排序的可能性,
                    a = 1;//1
                    x = b;//2
                }
            });

            Thread other = new Thread(new Runnable() {
                @Override
                public void run() {
                    //1，2 和 3，4并不是原子操作，
                    //不存在指令重排的情况下，共有的执行情况：
                    //（1，3，4，2） （1，3，2，4） （1，2，3，4）;（3，1，2，4）（3，1，4，2），（3，4，1，2）
                    //所有的情况中，不存在 x==0,y==0的情况。若有，这意味着两个线程的xy赋值都被提前了，即出现了指令重排。
                    b = 1;//3
                    y = a;//4
                }
            });
            one.start();other.start();
            one.join();other.join();
            //指令重排，任一线程均可出现指令重排，不存在依赖关系的指令存在重排的可能性。（为了更大效率利用cpu资源，是jvm的一种优化手段）
            //防止指令重排的手段：1. volatile 2. synchronized 原理？
            String result = "第" + i + "次 (" + x + "," + y + "）";
            if(x == 0 && y == 0) {
                System.err.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }
    public static void shortWait(long interval){
        long start = System.nanoTime();
        long end;
        do{
            end = System.nanoTime();
        }while(start + interval >= end);
    }
}
```



# 字节码

泛型，编译器会自动生成桥接字节码

```java
public interface SupperClass<T> {
    void method(T t);
}
```

```java
public class SubClass implements SupperClass<String> {
    @Override
    public void method(String s) {
        System.out.println(s);
    }
}
```

```
Exception in thread "main" abc
java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String
	at com.github.chuangkel.java_learn.base.generic.SubClass.method(SubClass.java:9)
	at com.github.chuangkel.java_learn.base.generic.Main.main(Main.java:14)
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
```



# 自动内存管理机制

## java内存区域与内存溢出异常

### 程序计数器

* 当前线程所执行的字节码的行号指示器
* 唯一一个没有OutOfMemoryError异常的区域

### 虚拟机栈

* 一个栈（虚拟机栈）供一个线程使用

* 一个方法调用对应一个栈帧，一个方法的调用过程就是一个栈帧入栈到出栈的过程。

* 一个虚拟机栈对应N个栈帧

* 栈帧 （存储了局部变量表，操作数栈、动态链接、方法出口等）

* 局部变量表：存储了八大基本类型（byte,boolean,short,char,int,float,long,double)、对象应用refrence类型、returnAddress类型（指向一条字节码的类型）
* double、long占用了两个局部变量空间，其余类型占用一个局部变量空间。局部变量的空间大小是编译时期就确定的，运行时不会改变。
* 两种异常：
  * 如果请求栈的深度（递归调用次数过多）超过规定的最大栈的深度，则抛出StackOverflowError异常。
  * 如果虚拟机栈可以动态扩展，当无法申请足够的内存时，则抛出OutOfMemoryError异常。

### 本地方法栈

* 和虚拟机栈的作用是类似的，也会抛出StackOverflowError异常和OutOfMemoryError异常。

### 方法区

* 方法区或称为永久代
* 存放常量（被final修饰），静态变量，类信息和即时编译后的代码等
* jdk1.7 已经把原本存放在永久代的字符串常量池移出。



#### 运行时常量池

* 定义：运行时常量池是方法区的一部分。class文件中除了版本，字段，方法，接口等信息外，还有一项信息是常量池，用于存放编译时期生成的字面量和符号引用。这部分内容是在类加载之后进入运行时常量池中存放的。

### java堆

* java堆也被成为GC堆
* java堆分为新生代和老年代。新生代又分为Eden，from Servivor，to Servivor。
* 线程共享的java堆可能划分出几个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB)
* java堆处于物理上不连续的空间中，只需要逻辑上是连续的即可。可以通过-Xmx和-Xms控制，当无法再扩展时，将会抛出OutOfMemoryError异常。

#### 对象的创建

普通java对象是一个什么样的创建过程呢？ （不包括Class对象和数组对象）

当遇到一个new关键字时，首先回去运行时常量池中查找是否已经存在一个类的符号引用，并且检查这个符号引用代表的类是否加载，验证，准备，解析和初始化过，如果没有则必须先执行相应的类加载过程。在类加载检查通过过后，接下来便是为新对象分配内存，为对象分配内存的任务就是将一块固定大小的内存空间从java堆中划分出来，有两种方法：指针碰撞和空闲列表方法。指针碰撞即维护的是两块空间，一块连续使用的空间，一块连续空闲的空间，中间分界的指针是一个指示器，把指示器向后移动一段对象大小的距离。 空闲列表需要维护一个列表，来记录哪些空间可以使用。

创建对象是十分频繁的操作，在多线程并发下也是不安全的。有两种解决方法：1. 控制多线程的并发 2. 每一个线程单独分配一小块内存（称为本地线程的内存缓冲Thread Local Alloction Buffer，TLAB），线程需要需要内存，就在线程自己的TLAB上分配，只有TLAB用完时才需要同步。

#### 对象的内存布局

对象分为三部分，对象头（Header)、实例数据（Instance Data）、和对齐填充（Padding）

对象头中包含两部分信息：

1. 对象自身运行时数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID,偏向时间戳等，这部分数据在32bit虚拟机中占32bit，在64bit虚拟机中占64bit，官方称“Mark Word”。为了节省空间，Mark Word被设计成非固定的数据结构以便在极小的空间内存储更多的信息。比如32bit虚拟机下：

   未锁定状态：25bit存储哈希值，4bit存储gc分代年龄，2bit存储锁标识位，1bit固定为0

   其他状态：

   ![1571039443563](/..\img\1571039443563.png)

2. 第二部分是类型指针，执行它的类元数据的指针。虚拟机通过这个来判断该对象属于哪个类的实例

### 2.4.3 方法区和运行时常量池溢出

jdk1.6之前，字符串常量池分配在方法区（永久代）中。jdk1.6之后字符串常量池改成放入堆中，以下代码执行时java堆异常。


```java
/**
 * VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>();
        //10MB的PermSize在integer范围内足够产生OOM了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
```

> 运行结果

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.lang.Integer.toString(Integer.java:403)
	at java.lang.String.valueOf(String.java:3099)
	at com.github.chuangkel.java_learn.base.jvm.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
```



## 垃圾回收器与内存分配策略



## 虚拟机性能监控与故障处理工具



## 调优案例分析与实战





两个线程直接有哪些通信方式，同享变量的方式？



# jvm基本原理

## jvm内存结构

* 线程私有：虚拟机栈（本地虚拟机栈），程序计数器
* 线程公共：堆，方法区

java堆划分为两个区域: 新生代(young)、老年代(old)

新生代又分为三个区域：eden,from survivor,to survivor

#### 虚拟机栈

> 会抛出两种异常：
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
>
> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。



局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这
个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变
量表的大小。

#### java堆

> 会抛出OutOfMemoryError异常。

#### 为什么要指定堆的初始最大值和最小值？

堆的大小用-Xms（初始堆大小）、-Xmx（最大堆大小）指定

新生代 eden:from:to = 8:1:1可以通过-XX:SurvivorRatio来指定

两种gc:minor gc和full gc (major gc)

eden+from作为新生代使用的区域，进行gc之后，判断存活对象大小是否小于to的大小，小于拷贝到to区，然后清除掉eden和from区域，并将还存活的对象的年龄+1，当达到15（默认）之后进入老年代  -XX:MaxTenuringThreshold可以设定进入老年代的年龄，对于大的对象也可以直接进入老年代。

## jvm内存模型

> 主内存+工作内存。硬件上的内存cpu寄存器、cpu缓存和主内存，物理内存和内存模型划分是交叉的关系。
>
> JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。

* 主内存	
  * 存放对象、类信息、静态变量
  * 包含了
* 工作内存
  * 存放方法局部变量，程序计数器信息的
  * 包含了

| 回收算法 | 思想 | 所用的地方 |
| -------- | ---- | ---------- |
| 标记复制 |      | 新生代     |
| 标记清除 |      | 老年代     |
| 标记整理 |      | 老年代     |
|          |      |            |

### 运行时常量池

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不 要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，**运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法**。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申 请到内存时会抛出OutOfMemoryError异常。 

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

 类和接口的全限定名（Fully Qualified Name） 

字段的名称和描述符（Descriptor） 

方法的名称和描述符

 Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

# GC算法&GC收集器

## GC算法



## GC收集器

* serial 单线程

* parNew 多线程

| GC收集器种类 | stop the world     | 算法 | 工作线程  | 针对回收区域 | 搭配使用 |      |
| ------------ | ------------------ | ---- | --------- | ------------ | -------- | ---- |
| serial       | 是                 |      | 单线程    |              |          |      |
| parNew       | 是                 |      | 多线程    |              |          |      |
| cms          | 更短暂暂停用户线程 |      | 单/多线程 |              |          |      |



