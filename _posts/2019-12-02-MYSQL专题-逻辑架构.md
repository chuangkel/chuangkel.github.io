---
layout:     post
title:	MYSQL专题
subtitle: 	逻辑架构
date:       2019-12-02
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数据库
---

#  逻辑架构

**引言**

1. 为什么要同步redo log而不是保持数据直接修改的同步？即redo log同步来出现脏数据时进行重做 vs 数据修改直接持久化到磁盘 两个的代价前者要低一点，为什么呢？ 为什么要这么设计呢？
2. 多版本控制会引发不可重复读的问题吗？ 
3. redo log日志在事务未提交前就已经开始把redo log持久化到磁盘，如果事务回滚了会发生什么？
4. update test_table set close = 100 where name = 1 如果name不是索引列的话，此更新会使用行锁还是表锁？
5. Checkpoint的作用？
6. select lock in share mode 和 select的区别？
7. mysql各引擎自己的区别?
8. 为什么能实现引擎的组件化？
9. innodb下的线程？
10. innodb下的缓冲池？
11. innodb下的页？

**分析**
### 1. 为什么要同步redo log而不是保持数据直接修改的同步？即redo log同步来出现脏数据时进行重做 vs 数据修改直接持久化到磁盘 两个的代价前者要低一点，为什么呢？ 为什么要这么设计呢？



### 2. 多版本控制会引发不可重复读的问题吗？ 

不可重复读的定义： 同一个事物两次查询同一行或相同的几行记录，前后两次查询的行内数据不一致。  多版本控制下，写的事务会新增一个版本，读的事务读的是在此之前最新的版本。 那么在一个事务当中两次读的间隔时间之内 如果有写事务提交了版本，此时最新的版本号改变，那么读事务的第二次读的行内数据和第一次读的行内数据就可能不一致了。 

在默认隔离级别可重复读下，行的读取加了gap lock吗？ 若在查询的范围之间加锁，确实可以到达可重复读的效果。事实是这样的吗

锁和多版本控制是怎么协调的？多版本是将需要写的版本拷贝一份作为一个版本，但是未提交前这个版本并不会被其他事务读到。

一个事务两次查询，读取的可以是两个版本吗？



### 3. redo log日志在事务未提交前就已经开始把redo log持久化到磁盘，如果事务回滚了会发生什么？



### 4. update test_table set close = 100 where name = 1 如果name不是索引列的话，此更新会使用行锁还是表锁？



### 5. Checkpoint的作用？
master thread 定期执行checkpoint将脏页刷回磁盘
页空间不够用时，根据页淘汰LRU算法执行checkpoint将脏页刷回磁盘
async/sync执行
redo log 不可用时

### 6. innodb下的线程？
1. master thread: 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证了数据 的一致性，包括脏页的刷新，合并插入缓冲（insert buffer)，undo页的回收。
2. io thread: 在innodb引擎中使用了大量的async io (AIO) 来处理写io请求，这样极大地提高了数据库的性能，而io thread 的工作主要是负责这些io请求的回调（call back)处理。共有四种io thread, 分别是read、write、redo/undo log io thread、insert buffer thread 。
3. purge thread: 事务提交之后，所使用的undo log日志不再需要，因此需要purge thread 来回收已经分配并使用的undo log页。通过以下配置文件在启动时启动purge thread。

```mysql
[mysqld]
innodb_purge_threads=1
```

4. page cleaner thread:  page cleaner thread 是innodb 1.2.x版本中引入的，作用是将脏页刷回磁盘，其实就是master thread的将脏页刷回磁盘的工作全部交给page cleaner thread来处理，提高了innodb存储引擎的性能。

### 7. innodb下的缓冲池？



### 8. innodb下的页？


## 正文

- 连接器层 
  - 功能：连接处理，授权认证，安全
- 服务器层
  - 查询缓存
  - 解析器
  - 优化器
  - 执行器
  - binlog日志
- 存储引擎层
  - InnoDB
  - MyISAM
  - Memory



* 基于行的复制



* 基于语句的复制



* 异步复制

![img](/../img/数据库异步复制.png)



* 半同步复制

![img](/../img/数据半同步复制.png)



复制过程中的线程

* 主库开启dump thread复制响应从库IO thread请求

* 从库开启IO thread，负责连接主库，请求binlog,将binlog写入relay-log(中继日志)
* 从库开启 Sql thread，负责执行relay-log事件



#### bin log和redo log及undo log的区别？

> bin log 先于redo log产生，可以在my.cnf配置文件中配置相关参数

* bin log
  * 在服务层产生，针对大多数存储引擎
  * 全量拷贝，事务所有的操作。T事务增加一行row，然后删除row，会记录下操作过程。
  * sync_binlog参数：控制bin log 同步到磁盘的频率
  * sync_binlog默认值0，不主动同步
  * sync_binlog值为1，每写一次bin log 同步一次磁盘，最安全
  
* redo log（事务提交到内存，所以需要redo log日志持久化到磁盘，掉电之后进行数据的恢复）
  * 在存储引擎层，是innodb产生的
  * 事务终态拷贝，具有幂等性（同一个数据操作？），T事务增加一行row，然后删除row，相当于记录不会修改。
  * redo log包括内存缓冲日志（redo log buffer）、磁盘持久化日志（redo log file）两部分。内存缓冲日志持久化到磁盘通过参数innodb_flush_log_at_trx_commit 来控制
    * innodb_flush_log_at_trx_commit 为1，事务提交立刻提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据安全，耗时较长）
    * innodb_flush_log_at_trx_commit 为0，每秒钟提交redo log buffer 到 os buffer，并且调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短）
    * innodb_flush_log_at_trx_commit 为2，事务提交立刻提交redo log buffer 到 os buffer，并且每秒调用fsync()函数，将os buffer提交到磁盘。（数据较不安全，耗时较短，可以防止mysqld 进程崩溃造成的数据丢失）
  
  * fsync()系统调用，将内核缓存提交到磁盘

![img](/../img/fsync用户空间到内核空间)

* undo log

  > undo log提供回滚和多个行版本控制(MVCC)，事务失败回滚时，会借助undo log进行回滚。
  >
  > * 回滚：undo log 是逻辑日志（redo log 是物理日志），undo log 会记录相反的操作（delete 一条记录会产生一条insert记录的日志，update会产生一条相反的update日志）。
  >
  > * 多个行版本控制(MVCC)：某一行被锁定而需要读取时，从undo log日志中解析出上一个版本记录的数据，实现非锁定一致性读取。



### MySQL-LSN

查看lsn:
   show engine innodb status

   Log sequence number 2687274848548 
   Log flushed up to 2687274848516
   Pages flushed up to 2687273963960
   Last checkpoint at 2687273963960

   1 简单说明

   Log sequence number: 当前系统最大的LSN号
   log flushed up to:当前已经写入redo日志文件的LSN
   pages flushed up to：已经将更改写入脏页的lsn号
   Last checkpoint at就是系统最后一次刷新buffer pool脏中页数据到磁盘的checkpoint
   2 以上4个LSN是递减的，即： LSN1>=LSN2>=LSN3>=LSN4.
   3 内容

​     每个数据页有LSN，重做日志有LSN，checkpoint有LSN。

  4 定义说明
    1 LSN（log sequence number）日志序列号，5.6.3之后占用8字节，LSN主要用于发生crash时对数据进行recovery，LSN是一个一直递增的整型数字，表示事务写入到日志的字节总量。
     LSN不仅只存在于重做日志中，在每个数据页头部也会有对应的LSN号，该LSN记录当前页最后一次修改的LSN号，用于在recovery时对比重做日志LSN号决定是否对该页进行恢复数据。前面说的checkpoint也是有LSN号记录的，LSN号串联起一个事务开始到恢复的过程。

例子：  show engine innodb status

```
| InnoDB |      |
=====================================
191008 10:23:24 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 58 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 68 1_second, 68 sleeps, 5 10_second, 20 background, 20 flush
srv_master_thread log flush and writes: 68
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 8, signal count 8
Mutex spin waits 7, rounds 72, OS waits 2
RW-shared spins 6, rounds 180, OS waits 6
RW-excl spins 0, rounds 0, OS waits 0
Spin rounds per wait: 10.29 mutex, 30.00 RW-shared, 0.00 RW-excl
------------
TRANSACTIONS
------------
Trx id counter 340C
Purge done for trx's n:o < 3405 undo n:o < 0
History list length 243
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 0, not started
MySQL thread id 14, OS thread handle 0x1478, query id 252 localhost 127.0.0.1 ODBC
show engine innodb status
--------
FILE I/O
--------
I/O thread 0 state: wait Windows aio (insert buffer thread)
I/O thread 1 state: wait Windows aio (log thread)
I/O thread 2 state: wait Windows aio (read thread)
I/O thread 3 state: wait Windows aio (read thread)
I/O thread 4 state: wait Windows aio (read thread)
I/O thread 5 state: wait Windows aio (read thread)
I/O thread 6 state: wait Windows aio (write thread)
I/O thread 7 state: wait Windows aio (write thread)
I/O thread 8 state: wait Windows aio (write thread)
I/O thread 9 state: wait Windows aio (write thread)
Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] ,
 ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0
Pending flushes (fsync) log: 0; buffer pool: 0
536 OS file reads, 38 OS file writes, 24 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 276707, node heap has 1 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
---
LOG
---
Log sequence number 4683173
Log flushed up to   4683173
Last checkpoint at  4683173
0 pending log writes, 0 pending chkp writes
18 log i/o's done, 0.00 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 137363456; in additional pool allocated 0
Dictionary memory allocated 58289
Buffer pool size   8192
Free buffers       7793
Database pages     398
Old database pages 0
Modified db pages  0
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 397, created 1, written 21
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 398, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
1 read views open inside InnoDB
Main thread id 6572, state: waiting for server activity
Number of rows inserted 1, updated 1, deleted 0, read 12
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
```





### InnoDB页结构

> InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16KB。一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。InnoDB有多种页，索引页，Undo页，Inode页，系统页，BloB页等。

![img](/../img/innodb页结构图.jpg)

#### mysql索引和页的关系？

B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为了达到这个目的，磁盘按需读取，要求每次都会预读的长度一般为页的整数倍。而且数据库系统将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。并把B-tree中的m值设的非常大，就会让树的高度降低，有利于一次完全载入。

#### 磁盘块和索引

![](../img/B+%E6%A0%91%E7%A3%81%E7%9B%98%E5%9D%97.jpg)

如图所示是 `B+ Tree` 的数据结构。是由一个一个的磁盘块组成的树形结构，每个磁盘块由数据项和指针组成。

> 所有的数据都是存放在叶子节点，非叶子节点不存放数据。索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。

以磁盘块1为例，指针 P1 表示小于17的磁盘块，P2 表示在 17~35 之间的磁盘块，P3 则表示大于35的磁盘块。比如要查找数据项99，首先将磁盘块1 load 到内存中，发生 1 次 IO。接着通过二分查找发现 99 大于 35，所以找到了 P3 指针。通过P3 指针发生第二次 IO 将磁盘块4加载到内存。再通过二分查找发现大于87，通过 P3 指针发生了第三次 IO 将磁盘块11 加载到内存。最后再通过一次二分查找找到了数据项99。由此可见，如果一个几百万的数据查询只需要进行三次 IO 即可找到数据，那么整个效率将是非常高的。观察树的结构，发现查询需要经历几次 IO 是由树的高度来决定的，而树的高度又由磁盘块，数据项的大小决定的。磁盘块越大，数据项越小那么树的高度就越低。这也就是为什么索引字段要尽可能小的原因。

#### 为什么innodb表最大支持64TB?

innodb的页号是一个32bit int类型数值，一页大小默认为16KB，那么最多有2^32 * 16kb =  64TB

#### 页、磁盘块与扇区联系

* 概念
  * 扇区：磁盘的最小存储单位
  * 磁盘块：文件系统读写数据的最小单位
  * 页：内存的最小存储单位
* 联系
  * 一个磁盘块由连续几个（2^n）扇区组成
  * 页的大小为磁盘块大小的2^n倍
* 查看
  * 页大小查看： getconf PAGE_SIZE，常见为4K
  * 磁盘块大小查看：stat /boot/|grep 'IO Block'，常见为4K
  * 扇区大小查看：fdisk -l，常见为512Byte

