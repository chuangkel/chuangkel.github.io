---
layout:     post
title:	java虚拟机
subtitle: 	第二部分：自动内存管理机制
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# 第二部分：自动内存管理机制

## java内存区域与内存溢出异常

### 程序计数器

* 当前线程所执行的字节码的行号指示器
* 唯一一个没有OutOfMemoryError异常的区域

### 虚拟机栈

* 一个栈（虚拟机栈）供一个线程使用

* 一个方法调用对应一个栈帧，一个方法的调用过程就是一个栈帧入栈到出栈的过程。

* 一个虚拟机栈对应N个栈帧

* 栈帧 （存储了局部变量表，操作数栈、动态链接、方法出口等）

* 局部变量表：存储了八大基本类型（byte,boolean,short,char,int,float,long,double)、对象应用refrence类型、returnAddress类型（指向一条字节码的类型）
* double、long占用了两个局部变量空间，其余类型占用一个局部变量空间。局部变量的空间大小是编译时期就确定的，运行时不会改变。
* 两种异常：
  * 如果请求栈的深度（递归调用次数过多）超过规定的最大栈的深度，则抛出StackOverflowError异常。
  * 如果虚拟机栈可以动态扩展，当无法申请足够的内存时，则抛出OutOfMemoryError异常。

### 本地方法栈

* 和虚拟机栈的作用是类似的，也会抛出StackOverflowError异常和OutOfMemoryError异常。

### 方法区

* 方法区或称为永久代

* 存放常量（被final修饰），静态变量，类信息和即时编译后的代码等

* jdk1.7 已经把原本存放在永久代的字符串常量池移出。

#### 运行时常量池

* 定义：运行时常量池是方法区的一部分。class文件中除了版本，字段，方法，接口等信息外，还有一项信息是常量池，用于存放编译时期生成的字面量和符号引用。这部分内容是在类加载之后进入运行时常量池中存放的。

### java堆

* java堆也被成为GC堆
* java堆分为新生代和老年代。新生代又分为Eden，from Servivor，to Servivor。

* 线程共享的java堆可能划分出几个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB)
* java堆处于物理上不连续的空间中，只需要逻辑上是连续的即可。可以通过-Xmx和-Xms控制，当无法再扩展时，将会抛出OutOfMemoryError异常。

## 垃圾回收器与内存分配策略



## 虚拟机性能监控与故障处理工具



## 调优案例分析与实战





两个线程直接有哪些通信方式，同享变量的方式？

