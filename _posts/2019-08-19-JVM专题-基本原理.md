---
layout:     post
title:	JVM专题
subtitle: 	jvm基本原理
date:       2019-08-19
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# jvm基本原理

## jvm内存结构

* 线程私有：虚拟机栈（本地虚拟机栈），程序计数器
* 线程公共：堆，方法区

java堆划分为两个区域: 新生代(young)、老年代(old)

新生代又分为三个区域：eden,from survivor,to survivor

#### 虚拟机栈

> 会抛出两种异常：
>
> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
>
> 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。



局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这
个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变
量表的大小。

#### java堆

> 会抛出OutOfMemoryError异常。

#### 为什么要指定堆的初始最大值和最小值？

堆的大小用-Xms（初始堆大小）、-Xmx（最大堆大小）指定

新生代 eden:from:to = 8:1:1可以通过-XX:SurvivorRatio来指定

两种gc:minor gc和full gc (major gc)

eden+from作为新生代使用的区域，进行gc之后，判断存活对象大小是否小于to的大小，小于拷贝到to区，然后清除掉eden和from区域，并将还存活的对象的年龄+1，当达到15（默认）之后进入老年代  -XX:MaxTenuringThreshold可以设定进入老年代的年龄，对于大的对象也可以直接进入老年代。

## jvm内存模型

> 主内存+工作内存。硬件上的内存cpu寄存器、cpu缓存和主内存，物理内存和内存模型划分是交叉的关系。
>
> JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。

* 主内存	
  * 存放对象、类信息、静态变量
  * 包含了
* 工作内存
  * 存放方法局部变量，程序计数器信息的
  * 包含了

| 回收算法 | 思想 | 所用的地方 |
| -------- | ---- | ---------- |
| 标记复制 |      | 新生代     |
| 标记清除 |      | 老年代     |
| 标记整理 |      | 老年代     |
|          |      |            |

### 运行时常量池

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不 要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，**运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法**。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申 请到内存时会抛出OutOfMemoryError异常。 

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

 类和接口的全限定名（Fully Qualified Name） 

字段的名称和描述符（Descriptor） 

方法的名称和描述符

 Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。