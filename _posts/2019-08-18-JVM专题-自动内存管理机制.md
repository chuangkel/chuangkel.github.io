---
layout:     post
title:	JVM专题
subtitle: 	第二部分：自动内存管理机制
date:       2019-08-18
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
---

# 第二部分：自动内存管理机制

## java内存区域与内存溢出异常

### 程序计数器

* 当前线程所执行的字节码的行号指示器
* 唯一一个没有OutOfMemoryError异常的区域

### 虚拟机栈

* 一个栈（虚拟机栈）供一个线程使用

* 一个方法调用对应一个栈帧，一个方法的调用过程就是一个栈帧入栈到出栈的过程。

* 一个虚拟机栈对应N个栈帧

* 栈帧 （存储了局部变量表，操作数栈、动态链接、方法出口等）

* 局部变量表：存储了八大基本类型（byte,boolean,short,char,int,float,long,double)、对象应用refrence类型、returnAddress类型（指向一条字节码的类型）
* double、long占用了两个局部变量空间，其余类型占用一个局部变量空间。局部变量的空间大小是编译时期就确定的，运行时不会改变。
* 两种异常：
  * 如果请求栈的深度（递归调用次数过多）超过规定的最大栈的深度，则抛出StackOverflowError异常。
  * 如果虚拟机栈可以动态扩展，当无法申请足够的内存时，则抛出OutOfMemoryError异常。

### 本地方法栈

* 和虚拟机栈的作用是类似的，也会抛出StackOverflowError异常和OutOfMemoryError异常。

### 方法区

* 方法区或称为永久代
* 存放常量（被final修饰），静态变量，类信息和即时编译后的代码等
* jdk1.7 已经把原本存放在永久代的字符串常量池移出。



#### 运行时常量池

* 定义：运行时常量池是方法区的一部分。class文件中除了版本，字段，方法，接口等信息外，还有一项信息是常量池，用于存放编译时期生成的字面量和符号引用。这部分内容是在类加载之后进入运行时常量池中存放的。

### java堆

* java堆也被成为GC堆
* java堆分为新生代和老年代。新生代又分为Eden，from Servivor，to Servivor。
* 线程共享的java堆可能划分出几个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB)
* java堆处于物理上不连续的空间中，只需要逻辑上是连续的即可。可以通过-Xmx和-Xms控制，当无法再扩展时，将会抛出OutOfMemoryError异常。

#### 对象的创建

普通java对象是一个什么样的创建过程呢？ （不包括Class对象和数组对象）

当遇到一个new关键字时，首先回去运行时常量池中查找是否已经存在一个类的符号引用，并且检查这个符号引用代表的类是否加载，验证，准备，解析和初始化过，如果没有则必须先执行相应的类加载过程。在类加载检查通过过后，接下来便是为新对象分配内存，为对象分配内存的任务就是将一块固定大小的内存空间从java堆中划分出来，有两种方法：指针碰撞和空闲列表方法。指针碰撞即维护的是两块空间，一块连续使用的空间，一块连续空闲的空间，中间分界的指针是一个指示器，把指示器向后移动一段对象大小的距离。 空闲列表需要维护一个列表，来记录哪些空间可以使用。

创建对象是十分频繁的操作，在多线程并发下也是不安全的。有两种解决方法：1. 控制多线程的并发 2. 每一个线程单独分配一小块内存（称为本地线程的内存缓冲Thread Local Alloction Buffer，TLAB），线程需要需要内存，就在线程自己的TLAB上分配，只有TLAB用完时才需要同步。

#### 对象的内存布局

对象分为三部分，对象头（Header)、实例数据（Instance Data）、和对齐填充（Padding）

对象头中包含两部分信息：

1. 对象自身运行时数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID,偏向时间戳等，这部分数据在32bit虚拟机中占32bit，在64bit虚拟机中占64bit，官方称“Mark Word”。为了节省空间，Mark Word被设计成非固定的数据结构以便在极小的空间内存储更多的信息。比如32bit虚拟机下：

   未锁定状态：25bit存储哈希值，4bit存储gc分代年龄，2bit存储锁标识位，1bit固定为0

   其他状态：

   ![1571039443563](/..\img\1571039443563.png)

2. 第二部分是类型指针，执行它的类元数据的指针。虚拟机通过这个来判断该对象属于哪个类的实例

### 2.4.3 方法区和运行时常量池溢出

jdk1.6之前，字符串常量池分配在方法区（永久代）中。jdk1.6之后字符串常量池改成放入堆中，以下代码执行时java堆异常。


```java
/**
 * VM Args：-XX：PermSize=10M-XX：MaxPermSize=10M
 */
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        //使用List保持着常量池引用，避免Full GC回收常量池行为
        List<String> list = new ArrayList<String>();
        //10MB的PermSize在integer范围内足够产生OOM了
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
```

> 运行结果

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at java.lang.Integer.toString(Integer.java:403)
	at java.lang.String.valueOf(String.java:3099)
	at com.github.chuangkel.java_learn.base.jvm.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8
```



## 垃圾回收器与内存分配策略



## 虚拟机性能监控与故障处理工具



## 调优案例分析与实战





两个线程直接有哪些通信方式，同享变量的方式？

