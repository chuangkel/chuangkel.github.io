---
layout:     post
title:	线程那些事儿
subtitle: 	线程那些事儿
date:       2019-08-07
author:     chuangkel
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 线程 & 线程池
---

# 线程那些事儿

### Thread.yield()

> yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 
> 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。
### interrupt()的理解

```java
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }
	
   /**如果抛出异常，会清除中断状态 interrupted status
 	 * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;
```

> interrupt() 只改变中断状态，不会终止线程执行

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            while (true){} //endless loop
        });
        thread.start();
        thread.interrupt(); //只改变中断状态，并没有结束线程
}
//使用姿势
public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{
            while (!Thread.currentThread().isInterrupted()){
                System.out.println("sub thread is over");
            }
        });
        thread.start();
        Thread.sleep(100);
        thread.interrupt();
}
```

> thread.interrupt()中断时，若thread处于挂起，则会抛出中断异常

```java
public static void main(String[] args) {
        Thread thread = new Thread(()->{
            try {
                Thread.sleep(100); //抛出异常之前将中断状态置为false
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().isInterrupted());
            }
        });
        thread.start();
        thread.interrupt(); //将中断状态置为true
}
```

### interrupted()  **VS**  isInterrupted()

```java
public static boolean interrupted() {
       return currentThread().isInterrupted(true);//会清除中断状态
}
public boolean isInterrupted() {
       return isInterrupted(false);//不会清除中断状态
}
private native boolean isInterrupted(boolean ClearInterrupted);
```

### 总结：哪些情况下会清除中断状态？

* 用interrupted()来判断当前中断状态时，返回当前中断状态，并清除中断状态为false 。本质上是 isInterrupted(true) 
* 调用interrupt()方法时，当前线程处于挂起状态，会清除中断状态并抛出异常，如下情形会使线程挂起：
  * Object#wait() 、Object#wait(long) 、Object#wait(long, int)
  * Object#join() 、Object#join(long) 、Object#join(long, int)
  * Object#sleep(long) 、Object#sleep(long, int)
  * If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel} then the channel will be closed
  * If this thread is blocked in a {@link java.nio.channels.Selector} then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value



### Condition

> 生产者消费者设计模式实现



> 两个线程，A线程打印A,B线程打印B,要求打印ABABABABABABABABABAB

```java
public class PrintThread implements Runnable {
    private int COUNT = 10;
    private ReentrantLock reentrantLock;
    private Condition conditionA;
    private Condition conditionB;
    private String c;
    PrintThread(ReentrantLock reentrantLock,Condition conditionA,Condition conditionB,String c){
        this.reentrantLock = reentrantLock;
        this.conditionA = conditionA;
        this.conditionB = conditionB;
        this.c = c;
    }
    @Override
    public void run() {
        try{
            reentrantLock.lock();
            for(int i = 0;i < COUNT; i++){
                System.out.print(c);
                try {
                    conditionB.signal();
                    if(i < COUNT - 1){
                        conditionA.await();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }finally {
            reentrantLock.unlock();
        }
    }
}

public class ReentranLockTest {
    static ReentrantLock reentrantLock = new ReentrantLock();
    static Condition conditionA = reentrantLock.newCondition();
    static Condition conditionB = reentrantLock.newCondition();
    public static void main(String[] args) {
       PrintThread printThreadA = new PrintThread(reentrantLock,conditionA,conditionB,"A");
       PrintThread printThreadB = new PrintThread(reentrantLock,conditionB,conditionA,"B");
        Thread tA = new Thread(printThreadA);
        Thread tB = new Thread(printThreadB);
        tA.start();
        tB.start();
        //输出BABABABABABABABABABA或者ABABABABABABABABABAB
    }
}
```